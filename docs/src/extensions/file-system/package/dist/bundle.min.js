"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const vscode = require("vscode");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k2 in e) {
      if (k2 !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k2);
        Object.defineProperty(n, k2, d.get ? d : {
          enumerable: true,
          get: () => e[k2]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
function _mergeNamespaces(n, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e = m2[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k2 in e) {
        if (k2 !== "default" && !(k2 in n)) {
          const d = Object.getOwnPropertyDescriptor(e, k2);
          if (d) {
            Object.defineProperty(n, k2, d.get ? d : {
              enumerable: true,
              get: () => e[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const vscode__namespace = /* @__PURE__ */ _interopNamespaceDefault(vscode);
function _assertThisInitialized(e) {
  if (void 0 === e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function asyncGeneratorStep(n, t, e, r, o, a, c) {
  try {
    var i = n[a](c), u = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u) : Promise.resolve(u).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _classCallCheck(a, n) {
  if (!(a instanceof n))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t2) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e))
    return e;
  if (void 0 !== e)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function() {
    return e;
  };
  var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
    t2[e2] = r2.value;
  }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
  function define(t2, e2, r2) {
    return Object.defineProperty(t2, e2, {
      value: r2,
      enumerable: true,
      configurable: true,
      writable: true
    }), t2[e2];
  }
  try {
    define({}, "");
  } catch (t2) {
    define = function(t3, e2, r2) {
      return t3[e2] = r2;
    };
  }
  function wrap(t2, e2, r2, n2) {
    var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
    return o(a2, "_invoke", {
      value: makeInvokeMethod(t2, r2, c2)
    }), a2;
  }
  function tryCatch(t2, e2, r2) {
    try {
      return {
        type: "normal",
        arg: t2.call(e2, r2)
      };
    } catch (t3) {
      return {
        type: "throw",
        arg: t3
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart", l2 = "suspendedYield", f = "executing", s = "completed", y = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var p2 = {};
  define(p2, a, function() {
    return this;
  });
  var d = Object.getPrototypeOf, v2 = d && d(d(values([])));
  v2 && v2 !== r && n.call(v2, a) && (p2 = v2);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
  function defineIteratorMethods(t2) {
    ["next", "throw", "return"].forEach(function(e2) {
      define(t2, e2, function(t3) {
        return this._invoke(e2, t3);
      });
    });
  }
  function AsyncIterator(t2, e2) {
    function invoke(r3, o2, i2, a2) {
      var c2 = tryCatch(t2[r3], t2, o2);
      if ("throw" !== c2.type) {
        var u2 = c2.arg, h2 = u2.value;
        return h2 && "object" == typeof h2 && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
          invoke("next", t3, i2, a2);
        }, function(t3) {
          invoke("throw", t3, i2, a2);
        }) : e2.resolve(h2).then(function(t3) {
          u2.value = t3, i2(u2);
        }, function(t3) {
          return invoke("throw", t3, i2, a2);
        });
      }
      a2(c2.arg);
    }
    var r2;
    o(this, "_invoke", {
      value: function(t3, n2) {
        function callInvokeWithMethodAndArg() {
          return new e2(function(e3, r3) {
            invoke(t3, n2, e3, r3);
          });
        }
        return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e2, r2, n2) {
    var o2 = h;
    return function(i2, a2) {
      if (o2 === f)
        throw Error("Generator is already running");
      if (o2 === s) {
        if ("throw" === i2)
          throw a2;
        return {
          value: t,
          done: true
        };
      }
      for (n2.method = i2, n2.arg = a2; ; ) {
        var c2 = n2.delegate;
        if (c2) {
          var u2 = maybeInvokeDelegate(c2, n2);
          if (u2) {
            if (u2 === y)
              continue;
            return u2;
          }
        }
        if ("next" === n2.method)
          n2.sent = n2._sent = n2.arg;
        else if ("throw" === n2.method) {
          if (o2 === h)
            throw o2 = s, n2.arg;
          n2.dispatchException(n2.arg);
        } else
          "return" === n2.method && n2.abrupt("return", n2.arg);
        o2 = f;
        var p3 = tryCatch(e2, r2, n2);
        if ("normal" === p3.type) {
          if (o2 = n2.done ? s : l2, p3.arg === y)
            continue;
          return {
            value: p3.arg,
            done: n2.done
          };
        }
        "throw" === p3.type && (o2 = s, n2.method = "throw", n2.arg = p3.arg);
      }
    };
  }
  function maybeInvokeDelegate(e2, r2) {
    var n2 = r2.method, o2 = e2.iterator[n2];
    if (o2 === t)
      return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
    var i2 = tryCatch(o2, e2.iterator, r2.arg);
    if ("throw" === i2.type)
      return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
    var a2 = i2.arg;
    return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
  }
  function pushTryEntry(t2) {
    var e2 = {
      tryLoc: t2[0]
    };
    1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
  }
  function resetTryEntry(t2) {
    var e2 = t2.completion || {};
    e2.type = "normal", delete e2.arg, t2.completion = e2;
  }
  function Context(t2) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t2.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(e2) {
    if (e2 || "" === e2) {
      var r2 = e2[a];
      if (r2)
        return r2.call(e2);
      if ("function" == typeof e2.next)
        return e2;
      if (!isNaN(e2.length)) {
        var o2 = -1, i2 = function next() {
          for (; ++o2 < e2.length; )
            if (n.call(e2, o2))
              return next.value = e2[o2], next.done = false, next;
          return next.value = t, next.done = true, next;
        };
        return i2.next = i2;
      }
    }
    throw new TypeError(typeof e2 + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
    var e2 = "function" == typeof t2 && t2.constructor;
    return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
  }, e.mark = function(t2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
  }, e.awrap = function(t2) {
    return {
      __await: t2
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
    void 0 === i2 && (i2 = Promise);
    var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
    return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
      return t3.done ? t3.value : a2.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
    return this;
  }), define(g, "toString", function() {
    return "[object Generator]";
  }), e.keys = function(t2) {
    var e2 = Object(t2), r2 = [];
    for (var n2 in e2)
      r2.push(n2);
    return r2.reverse(), function next() {
      for (; r2.length; ) {
        var t3 = r2.pop();
        if (t3 in e2)
          return next.value = t3, next.done = false, next;
      }
      return next.done = true, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function(e2) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2)
        for (var r2 in this)
          "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
    },
    stop: function() {
      this.done = true;
      var t2 = this.tryEntries[0].completion;
      if ("throw" === t2.type)
        throw t2.arg;
      return this.rval;
    },
    dispatchException: function(e2) {
      if (this.done)
        throw e2;
      var r2 = this;
      function handle(n2, o3) {
        return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
      }
      for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
        var i2 = this.tryEntries[o2], a2 = i2.completion;
        if ("root" === i2.tryLoc)
          return handle("end");
        if (i2.tryLoc <= this.prev) {
          var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
          if (c2 && u2) {
            if (this.prev < i2.catchLoc)
              return handle(i2.catchLoc, true);
            if (this.prev < i2.finallyLoc)
              return handle(i2.finallyLoc);
          } else if (c2) {
            if (this.prev < i2.catchLoc)
              return handle(i2.catchLoc, true);
          } else {
            if (!u2)
              throw Error("try statement without catch or finally");
            if (this.prev < i2.finallyLoc)
              return handle(i2.finallyLoc);
          }
        }
      }
    },
    abrupt: function(t2, e2) {
      for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
        var o2 = this.tryEntries[r2];
        if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
          var i2 = o2;
          break;
        }
      }
      i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
      var a2 = i2 ? i2.completion : {};
      return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
    },
    complete: function(t2, e2) {
      if ("throw" === t2.type)
        throw t2.arg;
      return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
    },
    finish: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.finallyLoc === t2)
          return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
      }
    },
    catch: function(t2) {
      for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
        var r2 = this.tryEntries[e2];
        if (r2.tryLoc === t2) {
          var n2 = r2.completion;
          if ("throw" === n2.type) {
            var o2 = n2.arg;
            resetTryEntry(r2);
          }
          return o2;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(e2, r2, n2) {
      return this.delegate = {
        iterator: values(e2),
        resultName: r2,
        nextLoc: n2
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i)
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var localforage = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
(function(module2, exports2) {
  (function(f) {
    {
      module2.exports = f();
    }
  })(function() {
    return function e(t, n, r) {
      function s(o2, u) {
        if (!n[o2]) {
          if (!t[o2]) {
            var a = typeof commonjsRequire == "function" && commonjsRequire;
            if (!u && a)
              return a(o2, true);
            if (i)
              return i(o2, true);
            var f = new Error("Cannot find module '" + o2 + "'");
            throw f.code = "MODULE_NOT_FOUND", f;
          }
          var l2 = n[o2] = { exports: {} };
          t[o2][0].call(l2.exports, function(e2) {
            var n2 = t[o2][1][e2];
            return s(n2 ? n2 : e2);
          }, l2, l2.exports, e, t, n, r);
        }
        return n[o2].exports;
      }
      var i = typeof commonjsRequire == "function" && commonjsRequire;
      for (var o = 0; o < r.length; o++)
        s(r[o]);
      return s;
    }({ 1: [function(_dereq_, module3, exports3) {
      (function(global2) {
        var Mutation = global2.MutationObserver || global2.WebKitMutationObserver;
        var scheduleDrain;
        {
          if (Mutation) {
            var called = 0;
            var observer = new Mutation(nextTick);
            var element = global2.document.createTextNode("");
            observer.observe(element, {
              characterData: true
            });
            scheduleDrain = function() {
              element.data = called = ++called % 2;
            };
          } else if (!global2.setImmediate && typeof global2.MessageChannel !== "undefined") {
            var channel = new global2.MessageChannel();
            channel.port1.onmessage = nextTick;
            scheduleDrain = function() {
              channel.port2.postMessage(0);
            };
          } else if ("document" in global2 && "onreadystatechange" in global2.document.createElement("script")) {
            scheduleDrain = function() {
              var scriptEl = global2.document.createElement("script");
              scriptEl.onreadystatechange = function() {
                nextTick();
                scriptEl.onreadystatechange = null;
                scriptEl.parentNode.removeChild(scriptEl);
                scriptEl = null;
              };
              global2.document.documentElement.appendChild(scriptEl);
            };
          } else {
            scheduleDrain = function() {
              setTimeout(nextTick, 0);
            };
          }
        }
        var draining;
        var queue = [];
        function nextTick() {
          draining = true;
          var i, oldQueue;
          var len = queue.length;
          while (len) {
            oldQueue = queue;
            queue = [];
            i = -1;
            while (++i < len) {
              oldQueue[i]();
            }
            len = queue.length;
          }
          draining = false;
        }
        module3.exports = immediate;
        function immediate(task) {
          if (queue.push(task) === 1 && !draining) {
            scheduleDrain();
          }
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 2: [function(_dereq_, module3, exports3) {
      var immediate = _dereq_(1);
      function INTERNAL() {
      }
      var handlers = {};
      var REJECTED = ["REJECTED"];
      var FULFILLED = ["FULFILLED"];
      var PENDING = ["PENDING"];
      module3.exports = Promise2;
      function Promise2(resolver) {
        if (typeof resolver !== "function") {
          throw new TypeError("resolver must be a function");
        }
        this.state = PENDING;
        this.queue = [];
        this.outcome = void 0;
        if (resolver !== INTERNAL) {
          safelyResolveThenable(this, resolver);
        }
      }
      Promise2.prototype["catch"] = function(onRejected) {
        return this.then(null, onRejected);
      };
      Promise2.prototype.then = function(onFulfilled, onRejected) {
        if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
          return this;
        }
        var promise = new this.constructor(INTERNAL);
        if (this.state !== PENDING) {
          var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
          unwrap(promise, resolver, this.outcome);
        } else {
          this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
        }
        return promise;
      };
      function QueueItem(promise, onFulfilled, onRejected) {
        this.promise = promise;
        if (typeof onFulfilled === "function") {
          this.onFulfilled = onFulfilled;
          this.callFulfilled = this.otherCallFulfilled;
        }
        if (typeof onRejected === "function") {
          this.onRejected = onRejected;
          this.callRejected = this.otherCallRejected;
        }
      }
      QueueItem.prototype.callFulfilled = function(value) {
        handlers.resolve(this.promise, value);
      };
      QueueItem.prototype.otherCallFulfilled = function(value) {
        unwrap(this.promise, this.onFulfilled, value);
      };
      QueueItem.prototype.callRejected = function(value) {
        handlers.reject(this.promise, value);
      };
      QueueItem.prototype.otherCallRejected = function(value) {
        unwrap(this.promise, this.onRejected, value);
      };
      function unwrap(promise, func, value) {
        immediate(function() {
          var returnValue;
          try {
            returnValue = func(value);
          } catch (e) {
            return handlers.reject(promise, e);
          }
          if (returnValue === promise) {
            handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
          } else {
            handlers.resolve(promise, returnValue);
          }
        });
      }
      handlers.resolve = function(self2, value) {
        var result = tryCatch(getThen, value);
        if (result.status === "error") {
          return handlers.reject(self2, result.value);
        }
        var thenable = result.value;
        if (thenable) {
          safelyResolveThenable(self2, thenable);
        } else {
          self2.state = FULFILLED;
          self2.outcome = value;
          var i = -1;
          var len = self2.queue.length;
          while (++i < len) {
            self2.queue[i].callFulfilled(value);
          }
        }
        return self2;
      };
      handlers.reject = function(self2, error) {
        self2.state = REJECTED;
        self2.outcome = error;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callRejected(error);
        }
        return self2;
      };
      function getThen(obj) {
        var then = obj && obj.then;
        if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
          return function appyThen() {
            then.apply(obj, arguments);
          };
        }
      }
      function safelyResolveThenable(self2, thenable) {
        var called = false;
        function onError(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.reject(self2, value);
        }
        function onSuccess(value) {
          if (called) {
            return;
          }
          called = true;
          handlers.resolve(self2, value);
        }
        function tryToUnwrap() {
          thenable(onSuccess, onError);
        }
        var result = tryCatch(tryToUnwrap);
        if (result.status === "error") {
          onError(result.value);
        }
      }
      function tryCatch(func, value) {
        var out = {};
        try {
          out.value = func(value);
          out.status = "success";
        } catch (e) {
          out.status = "error";
          out.value = e;
        }
        return out;
      }
      Promise2.resolve = resolve2;
      function resolve2(value) {
        if (value instanceof this) {
          return value;
        }
        return handlers.resolve(new this(INTERNAL), value);
      }
      Promise2.reject = reject;
      function reject(reason) {
        var promise = new this(INTERNAL);
        return handlers.reject(promise, reason);
      }
      Promise2.all = all;
      function all(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var values = new Array(len);
        var resolved = 0;
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          allResolver(iterable[i], i);
        }
        return promise;
        function allResolver(value, i2) {
          self2.resolve(value).then(resolveFromAll, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
          function resolveFromAll(outValue) {
            values[i2] = outValue;
            if (++resolved === len && !called) {
              called = true;
              handlers.resolve(promise, values);
            }
          }
        }
      }
      Promise2.race = race;
      function race(iterable) {
        var self2 = this;
        if (Object.prototype.toString.call(iterable) !== "[object Array]") {
          return this.reject(new TypeError("must be an array"));
        }
        var len = iterable.length;
        var called = false;
        if (!len) {
          return this.resolve([]);
        }
        var i = -1;
        var promise = new this(INTERNAL);
        while (++i < len) {
          resolver(iterable[i]);
        }
        return promise;
        function resolver(value) {
          self2.resolve(value).then(function(response) {
            if (!called) {
              called = true;
              handlers.resolve(promise, response);
            }
          }, function(error) {
            if (!called) {
              called = true;
              handlers.reject(promise, error);
            }
          });
        }
      }
    }, { "1": 1 }], 3: [function(_dereq_, module3, exports3) {
      (function(global2) {
        if (typeof global2.Promise !== "function") {
          global2.Promise = _dereq_(2);
        }
      }).call(this, typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, { "2": 2 }], 4: [function(_dereq_, module3, exports3) {
      var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
        return typeof obj;
      } : function(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function getIDB() {
        try {
          if (typeof indexedDB !== "undefined") {
            return indexedDB;
          }
          if (typeof webkitIndexedDB !== "undefined") {
            return webkitIndexedDB;
          }
          if (typeof mozIndexedDB !== "undefined") {
            return mozIndexedDB;
          }
          if (typeof OIndexedDB !== "undefined") {
            return OIndexedDB;
          }
          if (typeof msIndexedDB !== "undefined") {
            return msIndexedDB;
          }
        } catch (e) {
          return;
        }
      }
      var idb = getIDB();
      function isIndexedDBValid() {
        try {
          if (!idb || !idb.open) {
            return false;
          }
          var isSafari = typeof openDatabase !== "undefined" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);
          var hasFetch = typeof fetch === "function" && fetch.toString().indexOf("[native code") !== -1;
          return (!isSafari || hasFetch) && typeof indexedDB !== "undefined" && // some outdated implementations of IDB that appear on Samsung
          // and HTC Android devices <4.4 are missing IDBKeyRange
          // See: https://github.com/mozilla/localForage/issues/128
          // See: https://github.com/mozilla/localForage/issues/272
          typeof IDBKeyRange !== "undefined";
        } catch (e) {
          return false;
        }
      }
      function createBlob(parts, properties) {
        parts = parts || [];
        properties = properties || {};
        try {
          return new Blob(parts, properties);
        } catch (e) {
          if (e.name !== "TypeError") {
            throw e;
          }
          var Builder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : WebKitBlobBuilder;
          var builder = new Builder();
          for (var i = 0; i < parts.length; i += 1) {
            builder.append(parts[i]);
          }
          return builder.getBlob(properties.type);
        }
      }
      if (typeof Promise === "undefined") {
        _dereq_(3);
      }
      var Promise$1 = Promise;
      function executeCallback(promise, callback) {
        if (callback) {
          promise.then(function(result) {
            callback(null, result);
          }, function(error) {
            callback(error);
          });
        }
      }
      function executeTwoCallbacks(promise, callback, errorCallback) {
        if (typeof callback === "function") {
          promise.then(callback);
        }
        if (typeof errorCallback === "function") {
          promise["catch"](errorCallback);
        }
      }
      function normalizeKey(key2) {
        if (typeof key2 !== "string") {
          console.warn(key2 + " used as a key, but it is not a string.");
          key2 = String(key2);
        }
        return key2;
      }
      function getCallback() {
        if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
          return arguments[arguments.length - 1];
        }
      }
      var DETECT_BLOB_SUPPORT_STORE = "local-forage-detect-blob-support";
      var supportsBlobs = void 0;
      var dbContexts = {};
      var toString = Object.prototype.toString;
      var READ_ONLY = "readonly";
      var READ_WRITE = "readwrite";
      function _binStringToArrayBuffer(bin) {
        var length2 = bin.length;
        var buf = new ArrayBuffer(length2);
        var arr = new Uint8Array(buf);
        for (var i = 0; i < length2; i++) {
          arr[i] = bin.charCodeAt(i);
        }
        return buf;
      }
      function _checkBlobSupportWithoutCaching(idb2) {
        return new Promise$1(function(resolve2) {
          var txn = idb2.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);
          var blob = createBlob([""]);
          txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, "key");
          txn.onabort = function(e) {
            e.preventDefault();
            e.stopPropagation();
            resolve2(false);
          };
          txn.oncomplete = function() {
            var matchedChrome = navigator.userAgent.match(/Chrome\/(\d+)/);
            var matchedEdge = navigator.userAgent.match(/Edge\//);
            resolve2(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);
          };
        })["catch"](function() {
          return false;
        });
      }
      function _checkBlobSupport(idb2) {
        if (typeof supportsBlobs === "boolean") {
          return Promise$1.resolve(supportsBlobs);
        }
        return _checkBlobSupportWithoutCaching(idb2).then(function(value) {
          supportsBlobs = value;
          return supportsBlobs;
        });
      }
      function _deferReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = {};
        deferredOperation.promise = new Promise$1(function(resolve2, reject) {
          deferredOperation.resolve = resolve2;
          deferredOperation.reject = reject;
        });
        dbContext.deferredOperations.push(deferredOperation);
        if (!dbContext.dbReady) {
          dbContext.dbReady = deferredOperation.promise;
        } else {
          dbContext.dbReady = dbContext.dbReady.then(function() {
            return deferredOperation.promise;
          });
        }
      }
      function _advanceReadiness(dbInfo) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.resolve();
          return deferredOperation.promise;
        }
      }
      function _rejectReadiness(dbInfo, err) {
        var dbContext = dbContexts[dbInfo.name];
        var deferredOperation = dbContext.deferredOperations.pop();
        if (deferredOperation) {
          deferredOperation.reject(err);
          return deferredOperation.promise;
        }
      }
      function _getConnection(dbInfo, upgradeNeeded) {
        return new Promise$1(function(resolve2, reject) {
          dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
          if (dbInfo.db) {
            if (upgradeNeeded) {
              _deferReadiness(dbInfo);
              dbInfo.db.close();
            } else {
              return resolve2(dbInfo.db);
            }
          }
          var dbArgs = [dbInfo.name];
          if (upgradeNeeded) {
            dbArgs.push(dbInfo.version);
          }
          var openreq = idb.open.apply(idb, dbArgs);
          if (upgradeNeeded) {
            openreq.onupgradeneeded = function(e) {
              var db = openreq.result;
              try {
                db.createObjectStore(dbInfo.storeName);
                if (e.oldVersion <= 1) {
                  db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);
                }
              } catch (ex) {
                if (ex.name === "ConstraintError") {
                  console.warn('The database "' + dbInfo.name + '" has been upgraded from version ' + e.oldVersion + " to version " + e.newVersion + ', but the storage "' + dbInfo.storeName + '" already exists.');
                } else {
                  throw ex;
                }
              }
            };
          }
          openreq.onerror = function(e) {
            e.preventDefault();
            reject(openreq.error);
          };
          openreq.onsuccess = function() {
            var db = openreq.result;
            db.onversionchange = function(e) {
              e.target.close();
            };
            resolve2(db);
            _advanceReadiness(dbInfo);
          };
        });
      }
      function _getOriginalConnection(dbInfo) {
        return _getConnection(dbInfo, false);
      }
      function _getUpgradedConnection(dbInfo) {
        return _getConnection(dbInfo, true);
      }
      function _isUpgradeNeeded(dbInfo, defaultVersion) {
        if (!dbInfo.db) {
          return true;
        }
        var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
        var isDowngrade = dbInfo.version < dbInfo.db.version;
        var isUpgrade = dbInfo.version > dbInfo.db.version;
        if (isDowngrade) {
          if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' + dbInfo.name + `" can't be downgraded from version ` + dbInfo.db.version + " to version " + dbInfo.version + ".");
          }
          dbInfo.version = dbInfo.db.version;
        }
        if (isUpgrade || isNewStore) {
          if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
              dbInfo.version = incVersion;
            }
          }
          return true;
        }
        return false;
      }
      function _encodeBlob(blob) {
        return new Promise$1(function(resolve2, reject) {
          var reader = new FileReader();
          reader.onerror = reject;
          reader.onloadend = function(e) {
            var base64 = btoa(e.target.result || "");
            resolve2({
              __local_forage_encoded_blob: true,
              data: base64,
              type: blob.type
            });
          };
          reader.readAsBinaryString(blob);
        });
      }
      function _decodeBlob(encodedBlob) {
        var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));
        return createBlob([arrayBuff], { type: encodedBlob.type });
      }
      function _isEncodedBlob(value) {
        return value && value.__local_forage_encoded_blob;
      }
      function _fullyReady(callback) {
        var self2 = this;
        var promise = self2._initReady().then(function() {
          var dbContext = dbContexts[self2._dbInfo.name];
          if (dbContext && dbContext.dbReady) {
            return dbContext.dbReady;
          }
        });
        executeTwoCallbacks(promise, callback, callback);
        return promise;
      }
      function _tryReconnect(dbInfo) {
        _deferReadiness(dbInfo);
        var dbContext = dbContexts[dbInfo.name];
        var forages = dbContext.forages;
        for (var i = 0; i < forages.length; i++) {
          var forage = forages[i];
          if (forage._dbInfo.db) {
            forage._dbInfo.db.close();
            forage._dbInfo.db = null;
          }
        }
        dbInfo.db = null;
        return _getOriginalConnection(dbInfo).then(function(db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db;
        }).then(function(db) {
          dbInfo.db = dbContext.db = db;
          for (var i2 = 0; i2 < forages.length; i2++) {
            forages[i2]._dbInfo.db = db;
          }
        })["catch"](function(err) {
          _rejectReadiness(dbInfo, err);
          throw err;
        });
      }
      function createTransaction(dbInfo, mode, callback, retries) {
        if (retries === void 0) {
          retries = 1;
        }
        try {
          var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
          callback(null, tx);
        } catch (err) {
          if (retries > 0 && (!dbInfo.db || err.name === "InvalidStateError" || err.name === "NotFoundError")) {
            return Promise$1.resolve().then(function() {
              if (!dbInfo.db || err.name === "NotFoundError" && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {
                if (dbInfo.db) {
                  dbInfo.version = dbInfo.db.version + 1;
                }
                return _getUpgradedConnection(dbInfo);
              }
            }).then(function() {
              return _tryReconnect(dbInfo).then(function() {
                createTransaction(dbInfo, mode, callback, retries - 1);
              });
            })["catch"](callback);
          }
          callback(err);
        }
      }
      function createDbContext() {
        return {
          // Running localForages sharing a database.
          forages: [],
          // Shared database.
          db: null,
          // Database readiness (promise).
          dbReady: null,
          // Deferred operations on the database.
          deferredOperations: []
        };
      }
      function _initStorage(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        var dbContext = dbContexts[dbInfo.name];
        if (!dbContext) {
          dbContext = createDbContext();
          dbContexts[dbInfo.name] = dbContext;
        }
        dbContext.forages.push(self2);
        if (!self2._initReady) {
          self2._initReady = self2.ready;
          self2.ready = _fullyReady;
        }
        var initPromises = [];
        function ignoreErrors() {
          return Promise$1.resolve();
        }
        for (var j2 = 0; j2 < dbContext.forages.length; j2++) {
          var forage = dbContext.forages[j2];
          if (forage !== self2) {
            initPromises.push(forage._initReady()["catch"](ignoreErrors));
          }
        }
        var forages = dbContext.forages.slice(0);
        return Promise$1.all(initPromises).then(function() {
          dbInfo.db = dbContext.db;
          return _getOriginalConnection(dbInfo);
        }).then(function(db) {
          dbInfo.db = db;
          if (_isUpgradeNeeded(dbInfo, self2._defaultConfig.version)) {
            return _getUpgradedConnection(dbInfo);
          }
          return db;
        }).then(function(db) {
          dbInfo.db = dbContext.db = db;
          self2._dbInfo = dbInfo;
          for (var k2 = 0; k2 < forages.length; k2++) {
            var forage2 = forages[k2];
            if (forage2 !== self2) {
              forage2._dbInfo.db = dbInfo.db;
              forage2._dbInfo.version = dbInfo.version;
            }
          }
        });
      }
      function getItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.get(key2);
                req.onsuccess = function() {
                  var value = req.result;
                  if (value === void 0) {
                    value = null;
                  }
                  if (_isEncodedBlob(value)) {
                    value = _decodeBlob(value);
                  }
                  resolve2(value);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openCursor();
                var iterationNumber = 1;
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (cursor) {
                    var value = cursor.value;
                    if (_isEncodedBlob(value)) {
                      value = _decodeBlob(value);
                    }
                    var result = iterator(value, cursor.key, iterationNumber++);
                    if (result !== void 0) {
                      resolve2(result);
                    } else {
                      cursor["continue"]();
                    }
                  } else {
                    resolve2();
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          var dbInfo;
          self2.ready().then(function() {
            dbInfo = self2._dbInfo;
            if (toString.call(value) === "[object Blob]") {
              return _checkBlobSupport(dbInfo.db).then(function(blobSupport) {
                if (blobSupport) {
                  return value;
                }
                return _encodeBlob(value);
              });
            }
            return value;
          }).then(function(value2) {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                if (value2 === null) {
                  value2 = void 0;
                }
                var req = store.put(value2, key2);
                transaction.oncomplete = function() {
                  if (value2 === void 0) {
                    value2 = null;
                  }
                  resolve2(value2);
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store["delete"](key2);
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onerror = function() {
                  reject(req.error);
                };
                transaction.onabort = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_WRITE, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.clear();
                transaction.oncomplete = function() {
                  resolve2();
                };
                transaction.onabort = transaction.onerror = function() {
                  var err2 = req.error ? req.error : req.transaction.error;
                  reject(err2);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.count();
                req.onsuccess = function() {
                  resolve2(req.result);
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key(n, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          if (n < 0) {
            resolve2(null);
            return;
          }
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var advanced = false;
                var req = store.openKeyCursor();
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(null);
                    return;
                  }
                  if (n === 0) {
                    resolve2(cursor.key);
                  } else {
                    if (!advanced) {
                      advanced = true;
                      cursor.advance(n);
                    } else {
                      resolve2(cursor.key);
                    }
                  }
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            createTransaction(self2._dbInfo, READ_ONLY, function(err, transaction) {
              if (err) {
                return reject(err);
              }
              try {
                var store = transaction.objectStore(self2._dbInfo.storeName);
                var req = store.openKeyCursor();
                var keys2 = [];
                req.onsuccess = function() {
                  var cursor = req.result;
                  if (!cursor) {
                    resolve2(keys2);
                    return;
                  }
                  keys2.push(cursor.key);
                  cursor["continue"]();
                };
                req.onerror = function() {
                  reject(req.error);
                };
              } catch (e) {
                reject(e);
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          var isCurrentDb = options.name === currentConfig.name && self2._dbInfo.db;
          var dbPromise = isCurrentDb ? Promise$1.resolve(self2._dbInfo.db) : _getOriginalConnection(options).then(function(db) {
            var dbContext = dbContexts[options.name];
            var forages = dbContext.forages;
            dbContext.db = db;
            for (var i = 0; i < forages.length; i++) {
              forages[i]._dbInfo.db = db;
            }
            return db;
          });
          if (!options.storeName) {
            promise = dbPromise.then(function(db) {
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
              }
              var dropDBPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.deleteDatabase(options.name);
                req.onerror = function() {
                  var db2 = req.result;
                  if (db2) {
                    db2.close();
                  }
                  reject(req.error);
                };
                req.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + options.name + '" until all open connections are closed');
                };
                req.onsuccess = function() {
                  var db2 = req.result;
                  if (db2) {
                    db2.close();
                  }
                  resolve2(db2);
                };
              });
              return dropDBPromise.then(function(db2) {
                dbContext.db = db2;
                for (var i2 = 0; i2 < forages.length; i2++) {
                  var _forage = forages[i2];
                  _advanceReadiness(_forage._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          } else {
            promise = dbPromise.then(function(db) {
              if (!db.objectStoreNames.contains(options.storeName)) {
                return;
              }
              var newVersion = db.version + 1;
              _deferReadiness(options);
              var dbContext = dbContexts[options.name];
              var forages = dbContext.forages;
              db.close();
              for (var i = 0; i < forages.length; i++) {
                var forage = forages[i];
                forage._dbInfo.db = null;
                forage._dbInfo.version = newVersion;
              }
              var dropObjectPromise = new Promise$1(function(resolve2, reject) {
                var req = idb.open(options.name, newVersion);
                req.onerror = function(err) {
                  var db2 = req.result;
                  db2.close();
                  reject(err);
                };
                req.onupgradeneeded = function() {
                  var db2 = req.result;
                  db2.deleteObjectStore(options.storeName);
                };
                req.onsuccess = function() {
                  var db2 = req.result;
                  db2.close();
                  resolve2(db2);
                };
              });
              return dropObjectPromise.then(function(db2) {
                dbContext.db = db2;
                for (var j2 = 0; j2 < forages.length; j2++) {
                  var _forage2 = forages[j2];
                  _forage2._dbInfo.db = db2;
                  _advanceReadiness(_forage2._dbInfo);
                }
              })["catch"](function(err) {
                (_rejectReadiness(options, err) || Promise$1.resolve())["catch"](function() {
                });
                throw err;
              });
            });
          }
        }
        executeCallback(promise, callback);
        return promise;
      }
      var asyncStorage = {
        _driver: "asyncStorage",
        _initStorage,
        _support: isIndexedDBValid(),
        iterate,
        getItem,
        setItem,
        removeItem,
        clear,
        length,
        key,
        keys,
        dropInstance
      };
      function isWebSQLValid() {
        return typeof openDatabase === "function";
      }
      var BASE_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      var BLOB_TYPE_PREFIX = "~~local_forage_type~";
      var BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;
      var SERIALIZED_MARKER = "__lfsc__:";
      var SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;
      var TYPE_ARRAYBUFFER = "arbf";
      var TYPE_BLOB = "blob";
      var TYPE_INT8ARRAY = "si08";
      var TYPE_UINT8ARRAY = "ui08";
      var TYPE_UINT8CLAMPEDARRAY = "uic8";
      var TYPE_INT16ARRAY = "si16";
      var TYPE_INT32ARRAY = "si32";
      var TYPE_UINT16ARRAY = "ur16";
      var TYPE_UINT32ARRAY = "ui32";
      var TYPE_FLOAT32ARRAY = "fl32";
      var TYPE_FLOAT64ARRAY = "fl64";
      var TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;
      var toString$1 = Object.prototype.toString;
      function stringToBuffer(serializedString) {
        var bufferLength = serializedString.length * 0.75;
        var len = serializedString.length;
        var i;
        var p2 = 0;
        var encoded1, encoded2, encoded3, encoded4;
        if (serializedString[serializedString.length - 1] === "=") {
          bufferLength--;
          if (serializedString[serializedString.length - 2] === "=") {
            bufferLength--;
          }
        }
        var buffer2 = new ArrayBuffer(bufferLength);
        var bytes = new Uint8Array(buffer2);
        for (i = 0; i < len; i += 4) {
          encoded1 = BASE_CHARS.indexOf(serializedString[i]);
          encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);
          encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);
          encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);
          bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return buffer2;
      }
      function bufferToString(buffer2) {
        var bytes = new Uint8Array(buffer2);
        var base64String = "";
        var i;
        for (i = 0; i < bytes.length; i += 3) {
          base64String += BASE_CHARS[bytes[i] >> 2];
          base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
          base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
          base64String += BASE_CHARS[bytes[i + 2] & 63];
        }
        if (bytes.length % 3 === 2) {
          base64String = base64String.substring(0, base64String.length - 1) + "=";
        } else if (bytes.length % 3 === 1) {
          base64String = base64String.substring(0, base64String.length - 2) + "==";
        }
        return base64String;
      }
      function serialize(value, callback) {
        var valueType = "";
        if (value) {
          valueType = toString$1.call(value);
        }
        if (value && (valueType === "[object ArrayBuffer]" || value.buffer && toString$1.call(value.buffer) === "[object ArrayBuffer]")) {
          var buffer2;
          var marker = SERIALIZED_MARKER;
          if (value instanceof ArrayBuffer) {
            buffer2 = value;
            marker += TYPE_ARRAYBUFFER;
          } else {
            buffer2 = value.buffer;
            if (valueType === "[object Int8Array]") {
              marker += TYPE_INT8ARRAY;
            } else if (valueType === "[object Uint8Array]") {
              marker += TYPE_UINT8ARRAY;
            } else if (valueType === "[object Uint8ClampedArray]") {
              marker += TYPE_UINT8CLAMPEDARRAY;
            } else if (valueType === "[object Int16Array]") {
              marker += TYPE_INT16ARRAY;
            } else if (valueType === "[object Uint16Array]") {
              marker += TYPE_UINT16ARRAY;
            } else if (valueType === "[object Int32Array]") {
              marker += TYPE_INT32ARRAY;
            } else if (valueType === "[object Uint32Array]") {
              marker += TYPE_UINT32ARRAY;
            } else if (valueType === "[object Float32Array]") {
              marker += TYPE_FLOAT32ARRAY;
            } else if (valueType === "[object Float64Array]") {
              marker += TYPE_FLOAT64ARRAY;
            } else {
              callback(new Error("Failed to get type for BinaryArray"));
            }
          }
          callback(marker + bufferToString(buffer2));
        } else if (valueType === "[object Blob]") {
          var fileReader = new FileReader();
          fileReader.onload = function() {
            var str = BLOB_TYPE_PREFIX + value.type + "~" + bufferToString(this.result);
            callback(SERIALIZED_MARKER + TYPE_BLOB + str);
          };
          fileReader.readAsArrayBuffer(value);
        } else {
          try {
            callback(JSON.stringify(value));
          } catch (e) {
            console.error("Couldn't convert value into a JSON string: ", value);
            callback(null, e);
          }
        }
      }
      function deserialize(value) {
        if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {
          return JSON.parse(value);
        }
        var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);
        var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);
        var blobType;
        if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {
          var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);
          blobType = matcher[1];
          serializedString = serializedString.substring(matcher[0].length);
        }
        var buffer2 = stringToBuffer(serializedString);
        switch (type) {
          case TYPE_ARRAYBUFFER:
            return buffer2;
          case TYPE_BLOB:
            return createBlob([buffer2], { type: blobType });
          case TYPE_INT8ARRAY:
            return new Int8Array(buffer2);
          case TYPE_UINT8ARRAY:
            return new Uint8Array(buffer2);
          case TYPE_UINT8CLAMPEDARRAY:
            return new Uint8ClampedArray(buffer2);
          case TYPE_INT16ARRAY:
            return new Int16Array(buffer2);
          case TYPE_UINT16ARRAY:
            return new Uint16Array(buffer2);
          case TYPE_INT32ARRAY:
            return new Int32Array(buffer2);
          case TYPE_UINT32ARRAY:
            return new Uint32Array(buffer2);
          case TYPE_FLOAT32ARRAY:
            return new Float32Array(buffer2);
          case TYPE_FLOAT64ARRAY:
            return new Float64Array(buffer2);
          default:
            throw new Error("Unkown type: " + type);
        }
      }
      var localforageSerializer = {
        serialize,
        deserialize,
        stringToBuffer,
        bufferToString
      };
      function createDbTable(t, dbInfo, callback, errorCallback) {
        t.executeSql("CREATE TABLE IF NOT EXISTS " + dbInfo.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], callback, errorCallback);
      }
      function _initStorage$1(options) {
        var self2 = this;
        var dbInfo = {
          db: null
        };
        if (options) {
          for (var i in options) {
            dbInfo[i] = typeof options[i] !== "string" ? options[i].toString() : options[i];
          }
        }
        var dbInfoPromise = new Promise$1(function(resolve2, reject) {
          try {
            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);
          } catch (e) {
            return reject(e);
          }
          dbInfo.db.transaction(function(t) {
            createDbTable(t, dbInfo, function() {
              self2._dbInfo = dbInfo;
              resolve2();
            }, function(t2, error) {
              reject(error);
            });
          }, reject);
        });
        dbInfo.serializer = localforageSerializer;
        return dbInfoPromise;
      }
      function tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {
        t.executeSql(sqlStatement, args, callback, function(t2, error) {
          if (error.code === error.SYNTAX_ERR) {
            t2.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [dbInfo.storeName], function(t3, results) {
              if (!results.rows.length) {
                createDbTable(t3, dbInfo, function() {
                  t3.executeSql(sqlStatement, args, callback, errorCallback);
                }, errorCallback);
              } else {
                errorCallback(t3, error);
              }
            }, errorCallback);
          } else {
            errorCallback(t2, error);
          }
        }, errorCallback);
      }
      function getItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName + " WHERE key = ? LIMIT 1", [key2], function(t2, results) {
                var result = results.rows.length ? results.rows.item(0).value : null;
                if (result) {
                  result = dbInfo.serializer.deserialize(result);
                }
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$1(iterator, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT * FROM " + dbInfo.storeName, [], function(t2, results) {
                var rows = results.rows;
                var length2 = rows.length;
                for (var i = 0; i < length2; i++) {
                  var item = rows.item(i);
                  var result = item.value;
                  if (result) {
                    result = dbInfo.serializer.deserialize(result);
                  }
                  result = iterator(result, item.key, i + 1);
                  if (result !== void 0) {
                    resolve2(result);
                    return;
                  }
                }
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function _setItem(key2, value, callback, retriesLeft) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            if (value === void 0) {
              value = null;
            }
            var originalValue = value;
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                dbInfo.db.transaction(function(t) {
                  tryExecuteSql(t, dbInfo, "INSERT OR REPLACE INTO " + dbInfo.storeName + " (key, value) VALUES (?, ?)", [key2, value2], function() {
                    resolve2(originalValue);
                  }, function(t2, error2) {
                    reject(error2);
                  });
                }, function(sqlError) {
                  if (sqlError.code === sqlError.QUOTA_ERR) {
                    if (retriesLeft > 0) {
                      resolve2(_setItem.apply(self2, [key2, originalValue, callback, retriesLeft - 1]));
                      return;
                    }
                    reject(sqlError);
                  }
                });
              }
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$1(key2, value, callback) {
        return _setItem.apply(this, [key2, value, callback, 1]);
      }
      function removeItem$1(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName + " WHERE key = ?", [key2], function() {
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function clear$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "DELETE FROM " + dbInfo.storeName, [], function() {
                resolve2();
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT COUNT(key) as c FROM " + dbInfo.storeName, [], function(t2, results) {
                var result = results.rows.item(0).c;
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$1(n, callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName + " WHERE id = ? LIMIT 1", [n + 1], function(t2, results) {
                var result = results.rows.length ? results.rows.item(0).key : null;
                resolve2(result);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$1(callback) {
        var self2 = this;
        var promise = new Promise$1(function(resolve2, reject) {
          self2.ready().then(function() {
            var dbInfo = self2._dbInfo;
            dbInfo.db.transaction(function(t) {
              tryExecuteSql(t, dbInfo, "SELECT key FROM " + dbInfo.storeName, [], function(t2, results) {
                var keys2 = [];
                for (var i = 0; i < results.rows.length; i++) {
                  keys2.push(results.rows.item(i).key);
                }
                resolve2(keys2);
              }, function(t2, error) {
                reject(error);
              });
            });
          })["catch"](reject);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getAllStoreNames(db) {
        return new Promise$1(function(resolve2, reject) {
          db.transaction(function(t) {
            t.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(t2, results) {
              var storeNames = [];
              for (var i = 0; i < results.rows.length; i++) {
                storeNames.push(results.rows.item(i).name);
              }
              resolve2({
                db,
                storeNames
              });
            }, function(t2, error) {
              reject(error);
            });
          }, function(sqlError) {
            reject(sqlError);
          });
        });
      }
      function dropInstance$1(options, callback) {
        callback = getCallback.apply(this, arguments);
        var currentConfig = this.config();
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            var db;
            if (options.name === currentConfig.name) {
              db = self2._dbInfo.db;
            } else {
              db = openDatabase(options.name, "", "", 0);
            }
            if (!options.storeName) {
              resolve2(getAllStoreNames(db));
            } else {
              resolve2({
                db,
                storeNames: [options.storeName]
              });
            }
          }).then(function(operationInfo) {
            return new Promise$1(function(resolve2, reject) {
              operationInfo.db.transaction(function(t) {
                function dropTable(storeName) {
                  return new Promise$1(function(resolve3, reject2) {
                    t.executeSql("DROP TABLE IF EXISTS " + storeName, [], function() {
                      resolve3();
                    }, function(t2, error) {
                      reject2(error);
                    });
                  });
                }
                var operations = [];
                for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {
                  operations.push(dropTable(operationInfo.storeNames[i]));
                }
                Promise$1.all(operations).then(function() {
                  resolve2();
                })["catch"](function(e) {
                  reject(e);
                });
              }, function(sqlError) {
                reject(sqlError);
              });
            });
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var webSQLStorage = {
        _driver: "webSQLStorage",
        _initStorage: _initStorage$1,
        _support: isWebSQLValid(),
        iterate: iterate$1,
        getItem: getItem$1,
        setItem: setItem$1,
        removeItem: removeItem$1,
        clear: clear$1,
        length: length$1,
        key: key$1,
        keys: keys$1,
        dropInstance: dropInstance$1
      };
      function isLocalStorageValid() {
        try {
          return typeof localStorage !== "undefined" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
          !!localStorage.setItem;
        } catch (e) {
          return false;
        }
      }
      function _getKeyPrefix(options, defaultConfig) {
        var keyPrefix = options.name + "/";
        if (options.storeName !== defaultConfig.storeName) {
          keyPrefix += options.storeName + "/";
        }
        return keyPrefix;
      }
      function checkIfLocalStorageThrows() {
        var localStorageTestKey = "_localforage_support_test";
        try {
          localStorage.setItem(localStorageTestKey, true);
          localStorage.removeItem(localStorageTestKey);
          return false;
        } catch (e) {
          return true;
        }
      }
      function _isLocalStorageUsable() {
        return !checkIfLocalStorageThrows() || localStorage.length > 0;
      }
      function _initStorage$2(options) {
        var self2 = this;
        var dbInfo = {};
        if (options) {
          for (var i in options) {
            dbInfo[i] = options[i];
          }
        }
        dbInfo.keyPrefix = _getKeyPrefix(options, self2._defaultConfig);
        if (!_isLocalStorageUsable()) {
          return Promise$1.reject();
        }
        self2._dbInfo = dbInfo;
        dbInfo.serializer = localforageSerializer;
        return Promise$1.resolve();
      }
      function clear$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var keyPrefix = self2._dbInfo.keyPrefix;
          for (var i = localStorage.length - 1; i >= 0; i--) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) === 0) {
              localStorage.removeItem(key2);
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function getItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result = localStorage.getItem(dbInfo.keyPrefix + key2);
          if (result) {
            result = dbInfo.serializer.deserialize(result);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function iterate$2(iterator, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var keyPrefix = dbInfo.keyPrefix;
          var keyPrefixLength = keyPrefix.length;
          var length2 = localStorage.length;
          var iterationNumber = 1;
          for (var i = 0; i < length2; i++) {
            var key2 = localStorage.key(i);
            if (key2.indexOf(keyPrefix) !== 0) {
              continue;
            }
            var value = localStorage.getItem(key2);
            if (value) {
              value = dbInfo.serializer.deserialize(value);
            }
            value = iterator(value, key2.substring(keyPrefixLength), iterationNumber++);
            if (value !== void 0) {
              return value;
            }
          }
        });
        executeCallback(promise, callback);
        return promise;
      }
      function key$2(n, callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var result;
          try {
            result = localStorage.key(n);
          } catch (error) {
            result = null;
          }
          if (result) {
            result = result.substring(dbInfo.keyPrefix.length);
          }
          return result;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function keys$2(callback) {
        var self2 = this;
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          var length2 = localStorage.length;
          var keys2 = [];
          for (var i = 0; i < length2; i++) {
            var itemKey = localStorage.key(i);
            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {
              keys2.push(itemKey.substring(dbInfo.keyPrefix.length));
            }
          }
          return keys2;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function length$2(callback) {
        var self2 = this;
        var promise = self2.keys().then(function(keys2) {
          return keys2.length;
        });
        executeCallback(promise, callback);
        return promise;
      }
      function removeItem$2(key2, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          var dbInfo = self2._dbInfo;
          localStorage.removeItem(dbInfo.keyPrefix + key2);
        });
        executeCallback(promise, callback);
        return promise;
      }
      function setItem$2(key2, value, callback) {
        var self2 = this;
        key2 = normalizeKey(key2);
        var promise = self2.ready().then(function() {
          if (value === void 0) {
            value = null;
          }
          var originalValue = value;
          return new Promise$1(function(resolve2, reject) {
            var dbInfo = self2._dbInfo;
            dbInfo.serializer.serialize(value, function(value2, error) {
              if (error) {
                reject(error);
              } else {
                try {
                  localStorage.setItem(dbInfo.keyPrefix + key2, value2);
                  resolve2(originalValue);
                } catch (e) {
                  if (e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") {
                    reject(e);
                  }
                  reject(e);
                }
              }
            });
          });
        });
        executeCallback(promise, callback);
        return promise;
      }
      function dropInstance$2(options, callback) {
        callback = getCallback.apply(this, arguments);
        options = typeof options !== "function" && options || {};
        if (!options.name) {
          var currentConfig = this.config();
          options.name = options.name || currentConfig.name;
          options.storeName = options.storeName || currentConfig.storeName;
        }
        var self2 = this;
        var promise;
        if (!options.name) {
          promise = Promise$1.reject("Invalid arguments");
        } else {
          promise = new Promise$1(function(resolve2) {
            if (!options.storeName) {
              resolve2(options.name + "/");
            } else {
              resolve2(_getKeyPrefix(options, self2._defaultConfig));
            }
          }).then(function(keyPrefix) {
            for (var i = localStorage.length - 1; i >= 0; i--) {
              var key2 = localStorage.key(i);
              if (key2.indexOf(keyPrefix) === 0) {
                localStorage.removeItem(key2);
              }
            }
          });
        }
        executeCallback(promise, callback);
        return promise;
      }
      var localStorageWrapper = {
        _driver: "localStorageWrapper",
        _initStorage: _initStorage$2,
        _support: isLocalStorageValid(),
        iterate: iterate$2,
        getItem: getItem$2,
        setItem: setItem$2,
        removeItem: removeItem$2,
        clear: clear$2,
        length: length$2,
        key: key$2,
        keys: keys$2,
        dropInstance: dropInstance$2
      };
      var sameValue = function sameValue2(x2, y) {
        return x2 === y || typeof x2 === "number" && typeof y === "number" && isNaN(x2) && isNaN(y);
      };
      var includes = function includes2(array, searchElement) {
        var len = array.length;
        var i = 0;
        while (i < len) {
          if (sameValue(array[i], searchElement)) {
            return true;
          }
          i++;
        }
        return false;
      };
      var isArray = Array.isArray || function(arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
      };
      var DefinedDrivers = {};
      var DriverSupport = {};
      var DefaultDrivers = {
        INDEXEDDB: asyncStorage,
        WEBSQL: webSQLStorage,
        LOCALSTORAGE: localStorageWrapper
      };
      var DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];
      var OptionalDriverMethods = ["dropInstance"];
      var LibraryMethods = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(OptionalDriverMethods);
      var DefaultConfig = {
        description: "",
        driver: DefaultDriverOrder.slice(),
        name: "localforage",
        // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
        // we can use without a prompt.
        size: 4980736,
        storeName: "keyvaluepairs",
        version: 1
      };
      function callWhenReady(localForageInstance, libraryMethod) {
        localForageInstance[libraryMethod] = function() {
          var _args = arguments;
          return localForageInstance.ready().then(function() {
            return localForageInstance[libraryMethod].apply(localForageInstance, _args);
          });
        };
      }
      function extend() {
        for (var i = 1; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            for (var _key in arg) {
              if (arg.hasOwnProperty(_key)) {
                if (isArray(arg[_key])) {
                  arguments[0][_key] = arg[_key].slice();
                } else {
                  arguments[0][_key] = arg[_key];
                }
              }
            }
          }
        }
        return arguments[0];
      }
      var LocalForage = function() {
        function LocalForage2(options) {
          _classCallCheck2(this, LocalForage2);
          for (var driverTypeKey in DefaultDrivers) {
            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {
              var driver = DefaultDrivers[driverTypeKey];
              var driverName = driver._driver;
              this[driverTypeKey] = driverName;
              if (!DefinedDrivers[driverName]) {
                this.defineDriver(driver);
              }
            }
          }
          this._defaultConfig = extend({}, DefaultConfig);
          this._config = extend({}, this._defaultConfig, options);
          this._driverSet = null;
          this._initDriver = null;
          this._ready = false;
          this._dbInfo = null;
          this._wrapLibraryMethodsWithReady();
          this.setDriver(this._config.driver)["catch"](function() {
          });
        }
        LocalForage2.prototype.config = function config(options) {
          if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
            if (this._ready) {
              return new Error("Can't call config() after localforage has been used.");
            }
            for (var i in options) {
              if (i === "storeName") {
                options[i] = options[i].replace(/\W/g, "_");
              }
              if (i === "version" && typeof options[i] !== "number") {
                return new Error("Database version must be a number.");
              }
              this._config[i] = options[i];
            }
            if ("driver" in options && options.driver) {
              return this.setDriver(this._config.driver);
            }
            return true;
          } else if (typeof options === "string") {
            return this._config[options];
          } else {
            return this._config;
          }
        };
        LocalForage2.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {
          var promise = new Promise$1(function(resolve2, reject) {
            try {
              var driverName = driverObject._driver;
              var complianceError = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
              if (!driverObject._driver) {
                reject(complianceError);
                return;
              }
              var driverMethods = LibraryMethods.concat("_initStorage");
              for (var i = 0, len = driverMethods.length; i < len; i++) {
                var driverMethodName = driverMethods[i];
                var isRequired = !includes(OptionalDriverMethods, driverMethodName);
                if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== "function") {
                  reject(complianceError);
                  return;
                }
              }
              var configureMissingMethods = function configureMissingMethods2() {
                var methodNotImplementedFactory = function methodNotImplementedFactory2(methodName) {
                  return function() {
                    var error = new Error("Method " + methodName + " is not implemented by the current driver");
                    var promise2 = Promise$1.reject(error);
                    executeCallback(promise2, arguments[arguments.length - 1]);
                    return promise2;
                  };
                };
                for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {
                  var optionalDriverMethod = OptionalDriverMethods[_i];
                  if (!driverObject[optionalDriverMethod]) {
                    driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);
                  }
                }
              };
              configureMissingMethods();
              var setDriverSupport = function setDriverSupport2(support) {
                if (DefinedDrivers[driverName]) {
                  console.info("Redefining LocalForage driver: " + driverName);
                }
                DefinedDrivers[driverName] = driverObject;
                DriverSupport[driverName] = support;
                resolve2();
              };
              if ("_support" in driverObject) {
                if (driverObject._support && typeof driverObject._support === "function") {
                  driverObject._support().then(setDriverSupport, reject);
                } else {
                  setDriverSupport(!!driverObject._support);
                }
              } else {
                setDriverSupport(true);
              }
            } catch (e) {
              reject(e);
            }
          });
          executeTwoCallbacks(promise, callback, errorCallback);
          return promise;
        };
        LocalForage2.prototype.driver = function driver() {
          return this._driver || null;
        };
        LocalForage2.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {
          var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error("Driver not found."));
          executeTwoCallbacks(getDriverPromise, callback, errorCallback);
          return getDriverPromise;
        };
        LocalForage2.prototype.getSerializer = function getSerializer(callback) {
          var serializerPromise = Promise$1.resolve(localforageSerializer);
          executeTwoCallbacks(serializerPromise, callback);
          return serializerPromise;
        };
        LocalForage2.prototype.ready = function ready(callback) {
          var self2 = this;
          var promise = self2._driverSet.then(function() {
            if (self2._ready === null) {
              self2._ready = self2._initDriver();
            }
            return self2._ready;
          });
          executeTwoCallbacks(promise, callback, callback);
          return promise;
        };
        LocalForage2.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {
          var self2 = this;
          if (!isArray(drivers)) {
            drivers = [drivers];
          }
          var supportedDrivers = this._getSupportedDrivers(drivers);
          function setDriverToConfig() {
            self2._config.driver = self2.driver();
          }
          function extendSelfWithDriver(driver) {
            self2._extend(driver);
            setDriverToConfig();
            self2._ready = self2._initStorage(self2._config);
            return self2._ready;
          }
          function initDriver(supportedDrivers2) {
            return function() {
              var currentDriverIndex = 0;
              function driverPromiseLoop() {
                while (currentDriverIndex < supportedDrivers2.length) {
                  var driverName = supportedDrivers2[currentDriverIndex];
                  currentDriverIndex++;
                  self2._dbInfo = null;
                  self2._ready = null;
                  return self2.getDriver(driverName).then(extendSelfWithDriver)["catch"](driverPromiseLoop);
                }
                setDriverToConfig();
                var error = new Error("No available storage method found.");
                self2._driverSet = Promise$1.reject(error);
                return self2._driverSet;
              }
              return driverPromiseLoop();
            };
          }
          var oldDriverSetDone = this._driverSet !== null ? this._driverSet["catch"](function() {
            return Promise$1.resolve();
          }) : Promise$1.resolve();
          this._driverSet = oldDriverSetDone.then(function() {
            var driverName = supportedDrivers[0];
            self2._dbInfo = null;
            self2._ready = null;
            return self2.getDriver(driverName).then(function(driver) {
              self2._driver = driver._driver;
              setDriverToConfig();
              self2._wrapLibraryMethodsWithReady();
              self2._initDriver = initDriver(supportedDrivers);
            });
          })["catch"](function() {
            setDriverToConfig();
            var error = new Error("No available storage method found.");
            self2._driverSet = Promise$1.reject(error);
            return self2._driverSet;
          });
          executeTwoCallbacks(this._driverSet, callback, errorCallback);
          return this._driverSet;
        };
        LocalForage2.prototype.supports = function supports(driverName) {
          return !!DriverSupport[driverName];
        };
        LocalForage2.prototype._extend = function _extend(libraryMethodsAndProperties) {
          extend(this, libraryMethodsAndProperties);
        };
        LocalForage2.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {
          var supportedDrivers = [];
          for (var i = 0, len = drivers.length; i < len; i++) {
            var driverName = drivers[i];
            if (this.supports(driverName)) {
              supportedDrivers.push(driverName);
            }
          }
          return supportedDrivers;
        };
        LocalForage2.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {
          for (var i = 0, len = LibraryMethods.length; i < len; i++) {
            callWhenReady(this, LibraryMethods[i]);
          }
        };
        LocalForage2.prototype.createInstance = function createInstance(options) {
          return new LocalForage2(options);
        };
        return LocalForage2;
      }();
      var localforage_js = new LocalForage();
      module3.exports = localforage_js;
    }, { "3": 3 }] }, {}, [4])(4);
  });
})(localforage);
var localforageExports = localforage.exports;
const R$2 = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports);
var eveit_min = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    t(exports2);
  }(commonjsGlobal, function(e) {
    function a(e2) {
      return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
        return typeof e3;
      } : function(e3) {
        return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
      })(e2);
    }
    function i(e2, t2) {
      for (var n = 0; n < t2.length; n++) {
        var r2 = t2[n];
        r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e2, r2.key, r2);
      }
    }
    function o(e2) {
      return function(e3) {
        if (Array.isArray(e3))
          return r(e3);
      }(e2) || function(e3) {
        if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"])
          return Array.from(e3);
      }(e2) || function(e3, t2) {
        if (e3) {
          if ("string" == typeof e3)
            return r(e3, t2);
          var n = Object.prototype.toString.call(e3).slice(8, -1);
          return "Map" === (n = "Object" === n && e3.constructor ? e3.constructor.name : n) || "Set" === n ? Array.from(e3) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(e3, t2) : void 0;
        }
      }(e2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function r(e2, t2) {
      (null == t2 || t2 > e2.length) && (t2 = e2.length);
      for (var n = 0, r2 = new Array(t2); n < t2; n++)
        r2[n] = e2[n];
      return r2;
    }
    var t = function() {
      function e2() {
        if (!(this instanceof e2))
          throw new TypeError("Cannot call a class as a function");
        this.usePrevEmit = true, this._map = {}, this._prevData = {};
      }
      var t2, n, r2;
      return t2 = e2, r2 = [{ key: "_", get: function() {
        return this.__ || (this.__ = new e2()), this.__;
      } }, { key: "usePrevEmit", get: function() {
        return this._.usePrevEmit;
      }, set: function(e3) {
        this._.usePrevEmit = e3;
      } }, { key: "emit", value: function(e3) {
        for (var t3, n2 = arguments.length, r3 = new Array(1 < n2 ? n2 - 1 : 0), i2 = 1; i2 < n2; i2++)
          r3[i2 - 1] = arguments[i2];
        (t3 = this._).emit.apply(t3, [e3].concat(r3));
      } }, { key: "off", value: function(e3, t3) {
        this._.off(e3, t3);
      } }, { key: "clear", value: function(e3) {
        this._.clear(e3);
      } }, { key: "on", value: function(e3, t3) {
        this._.on(e3, t3);
      } }, { key: "once", value: function(e3, t3) {
        this._.once(e3, t3);
      } }, { key: "onWait", value: function(e3) {
        this._.onWait(e3);
      } }, { key: "head", value: function(e3, t3) {
        this._.head(e3, t3);
      } }, { key: "headOnce", value: function(e3, t3) {
        this._.headOnce(e3, t3);
      } }], (n = [{ key: "hasEvent", value: function(e3) {
        return !!this._map[e3];
      } }, { key: "on", value: function(e3, t3) {
        var n2 = this;
        if ("object" === a(e3)) {
          var r3, i2 = [];
          for (r3 in e3)
            i2.push(this.on(r3, e3[r3]));
          return function() {
            i2.forEach(function(e4) {
              return e4();
            });
          };
        }
        if (!t3)
          throw new Error("fn is required");
        var o2 = this._formatTarget(t3);
        return this._checkPrev(e3, o2) && o2.once ? function() {
        } : (this._getList(e3).push(o2), function() {
          n2.off(e3, o2);
        });
      } }, { key: "_formatTarget", value: function(e3, t3) {
        return "function" == typeof e3 ? { listener: e3, once: null != t3 && t3, prev: this.usePrevEmit } : ("boolean" == typeof t3 && (e3.once = t3), e3);
      } }, { key: "emit", value: function(e3) {
        for (var t3 = arguments.length, n2 = new Array(1 < t3 ? t3 - 1 : 0), r3 = 1; r3 < t3; r3++)
          n2[r3 - 1] = arguments[r3];
        this._prevData[e3] = n2;
        var i2 = this._map[e3];
        if (!i2)
          return false;
        for (var o2 = 0; o2 < i2.length; o2++) {
          var a2 = i2[o2];
          a2.listener.apply(a2, n2), a2.once && (i2.splice(o2, 1), o2--);
        }
        return true;
      } }, { key: "off", value: function(e3, t3) {
        e3 = this._map[e3];
        if (!e3)
          return false;
        var n2 = e3.findIndex(function(e4) {
          return e4 === t3 || e4.listener === t3;
        });
        return -1 !== n2 && (e3.splice(n2, 1), true);
      } }, { key: "clear", value: function(e3) {
        return !!this._map[e3] && (delete this._map[e3], delete this._prevData[e3], true);
      } }, { key: "onWait", value: function(t3, n2) {
        var i2 = this;
        return new Promise(function(r3) {
          var e3 = function() {
            for (var e4 = arguments.length, t4 = new Array(e4), n3 = 0; n3 < e4; n3++)
              t4[n3] = arguments[n3];
            return r3(t4);
          };
          n2 && (e3 = Object.assign({ listener: e3 }, n2)), i2.once(t3, e3);
        });
      } }, { key: "destroy", value: function() {
        this._map = {}, this._prevData = {};
      } }, { key: "_checkPrev", value: function(e3, t3) {
        if (!t3.prev)
          return false;
        e3 = this._prevData[e3];
        return void 0 !== e3 && (t3.listener.apply(t3, o(e3)), true);
      } }, { key: "once", value: function(e3, t3) {
        return this.on(e3, this._formatTarget(t3, true));
      } }, { key: "head", value: function(e3, t3) {
        var n2 = this, r3 = this._formatTarget(t3);
        return this._checkPrev(e3, r3) && r3.once ? function() {
        } : (this._getList(e3).unshift(r3), function() {
          n2.off(e3, t3);
        });
      } }, { key: "headOnce", value: function(e3, t3) {
        return this.head(e3, this._formatTarget(t3, true));
      } }, { key: "_getList", value: function(e3) {
        var t3 = this._map[e3];
        return t3 || (this._map[e3] = t3 = []), t3;
      } }]) && i(t2.prototype, n), r2 && i(t2, r2), Object.defineProperty(t2, "prototype", { writable: false }), e2;
    }();
    t.version = "0.0.3", e.Eveit = t, e.default = t, Object.defineProperty(e, "__esModule", { value: true });
  });
})(eveit_min, eveit_min.exports);
function v(e, i) {
  (i == null || i > e.length) && (i = e.length);
  for (var t = 0, s = Array(i); t < i; t++)
    s[t] = e[t];
  return s;
}
function A$1(e) {
  if (Array.isArray(e))
    return v(e);
}
function I(e, i) {
  if (!(e instanceof i))
    throw new TypeError("Cannot call a class as a function");
}
function S(e, i) {
  for (var t = 0; t < i.length; t++) {
    var s = i[t];
    s.enumerable = s.enumerable || false, s.configurable = true, "value" in s && (s.writable = true), Object.defineProperty(e, E(s.key), s);
  }
}
function w$1(e, i, t) {
  return i && S(e.prototype, i), t && S(e, t), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function H$1(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function P() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _$1(e) {
  return A$1(e) || H$1(e) || L(e) || P();
}
function $$1(e, i) {
  if (typeof e != "object" || !e)
    return e;
  var t = e[Symbol.toPrimitive];
  if (t !== void 0) {
    var s = t.call(e, i || "default");
    if (typeof s != "object")
      return s;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (i === "string" ? String : Number)(e);
}
function E(e) {
  var i = $$1(e, "string");
  return typeof i == "symbol" ? i : i + "";
}
function L(e, i) {
  if (e) {
    if (typeof e == "string")
      return v(e, i);
    var t = {}.toString.call(e).slice(8, -1);
    return t === "Object" && e.constructor && (t = e.constructor.name), t === "Map" || t === "Set" ? Array.from(e) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? v(e, i) : void 0;
  }
}
var l = Symbol("E"), k = /* @__PURE__ */ function(e) {
  return e[e.Fork = 0] = "Fork", e[e.Append = 1] = "Append", e;
}(k || {}), O = /* @__PURE__ */ function() {
  function e() {
    var i = this, t, s, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = n.max, a = r === void 0 ? 0 : r, h = n.useStorage, o = h === void 0 ? false : h, g = n.storageKey, f = g === void 0 ? "_def_history_stack" : g, p2 = n.mode, b = p2 === void 0 ? 0 : p2, y = n.storageProvider, m2 = n.onStepChange, x2 = n.onHistorySizeChange, C = n.onHistoryOut;
    if (I(this, e), this.step = 0, this.size = 0, this.max = 40, this.list = [], this.index = 0, this.End = l, this.isActive = false, this.max = a, this.mode = b, o !== false && (y || f) && (o = true), o && (this.storageProvider = y || {
      read: function() {
        var u = localStorage.getItem(f);
        return u ? JSON.parse(u) : [];
      },
      write: function(u) {
        localStorage.setItem(f, JSON.stringify(u));
      }
    }), m2 && (this.osc = function() {
      return m2(i.step);
    }), x2 && (this.ohsc = function() {
      return x2(i.size);
    }), this.oho = C, (t = this.osc) === null || t === void 0 || t.call(this), (s = this.ohsc) === null || s === void 0 || s.call(this), o) {
      var c = this.storageProvider.read();
      c instanceof Promise ? c.then(function(d) {
        i.useCache(d);
      }) : this.useCache(c);
    }
  }
  return w$1(e, [{
    key: "useCache",
    value: function(t) {
      t.length !== 0 && this.push.apply(this, _$1(t));
    }
  }, {
    key: "setMax",
    value: function(t) {
      this.max = t;
    }
  }, {
    key: "setStep",
    value: function(t) {
      var s;
      this.step = t, (s = this.osc) === null || s === void 0 || s.call(this);
    }
  }, {
    key: "setHistoryIndex",
    value: function(t) {
      var s;
      this.isActive || (this.isActive = true), this.index = t, this.size = t, (s = this.ohsc) === null || s === void 0 || s.call(this);
    }
  }, {
    key: "back",
    value: function() {
      var t, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      if (!this.canBack(s))
        return s > 1 && (this.setStep(this.step - this.index), this.setHistoryIndex(0)), this.End;
      this.setStep(this.step - s), this.setHistoryIndex(this.index - s);
      var n = this.list[this.index];
      return (t = this.oho) === null || t === void 0 || t.call(this, n), n;
    }
  }, {
    key: "canBack",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      return this.index - t >= 0;
    }
  }, {
    key: "first",
    value: function() {
      return this.list.length === 0 ? l : (this.setStep(this.step - this.index), this.setHistoryIndex(0), this.list[0]);
    }
  }, {
    key: "last",
    value: function() {
      return this.list.length === 0 ? l : (this.setStep(this.step + this.list.length - this.index), this.setHistoryIndex(this.list.length - 1), this.list[this.list.length - 1]);
    }
  }, {
    key: "forward",
    value: function() {
      var t, s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      if (!this.canForward(s))
        return s > 1 && (this.setStep(this.step + this.list.length - this.index), this.setHistoryIndex(this.list.length - 1)), this.End;
      this.setStep(this.step + s), this.setHistoryIndex(this.index + s);
      var n = this.list[this.index];
      return (t = this.oho) === null || t === void 0 || t.call(this, n), n;
    }
  }, {
    key: "isEnd",
    value: function(t) {
      return t === l;
    }
  }, {
    key: "canForward",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      return this.index + t < this.list.length;
    }
  }, {
    key: "pop",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, s = this.list.length;
      if (s <= t) {
        var n = _$1(this.list);
        return this.clear(), n;
      }
      var r = s - t, a = this.list.splice(r), h = this.list.length;
      return h < this.index && (this.setHistoryIndex(h), this.setStep(this.step - (this.index - h))), a;
    }
  }, {
    key: "push",
    value: function() {
      var t, s = this.list.length;
      this.index < s && (this.step++, this.index++, this.mode === 0 && this.list.splice(this.index));
      var n = arguments.length, r = 0, a = n;
      this.max > 0 && s + n > this.max && (r = s + n - this.max, a = n - r), (t = this.list).push.apply(t, arguments), r && this.list.splice(0, r), this._onListChange(), a && (this.mode === 1 ? this.setHistoryIndex(this.list.length) : this.setHistoryIndex(this.index + a)), this.mode === 1 ? this.setStep(this.list.length) : this.setStep(this.step + a), this.isActive && (this.isActive = false);
    }
  }, {
    key: "clear",
    value: function() {
      this.list = [], this._onListChange(), this.setHistoryIndex(0), this.setStep(0), this.isActive = false;
    }
  }, {
    key: "replace",
    value: function(t) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.index;
      typeof this.list[s] > "u" || (this.list[s] = t, this._onListChange());
    }
  }, {
    key: "isLatest",
    get: function() {
      return this.index === this.list.length - 1;
    }
  }, {
    key: "_onListChange",
    value: function() {
      var t;
      (t = this.storageProvider) === null || t === void 0 || t.write(this.list);
    }
  }, {
    key: "current",
    value: function() {
      return this.list[this.index];
    }
  }]);
}();
O.Mode = k;
(function() {
  try {
    if (typeof document < "u") {
      var e = document.createElement("style");
      e.appendChild(document.createTextNode(".style-text{font-family:Menlo,Monaco,Courier New,monospace;font-size:var(--font-size);font-kerning:none;white-space:pre;line-height:var(--line-height);box-sizing:border-box}.full-parent{position:absolute;top:0;left:0;width:100%;height:100%}.editor-textarea::-webkit-scrollbar,.web-term-container::-webkit-scrollbar{width:5px;cursor:pointer;height:5px}.editor-textarea::-webkit-scrollbar-button,.web-term-container::-webkit-scrollbar-button{display:none}.editor-textarea::-webkit-scrollbar-track,.web-term-container::-webkit-scrollbar-track{display:none}.editor-textarea::-webkit-scrollbar-thumb,.web-term-container::-webkit-scrollbar-thumb{background-color:#777;cursor:pointer}.editor-textarea ::selection,.web-term-container ::selection{background-color:var(--selection-bg);color:var(--selection)}.web-term-container{position:relative;font-family:Menlo,Monaco,Courier New,monospace;font-size:var(--font-size);font-kerning:none;white-space:pre;line-height:var(--line-height);box-sizing:border-box;background-color:var(--background);color:var(--color);cursor:text}.web-term-container *{font-family:Menlo,Monaco,Courier New,monospace;font-size:var(--font-size);font-kerning:none;white-space:pre;line-height:var(--line-height);box-sizing:border-box}.editor-cursor{position:absolute;z-index:2;height:var(--line-height);background-color:var(--background);color:var(--color)}.editor-cursor.cursor-focus{background-color:var(--selection-bg);color:var(--selection)}.editor-cursor .editor-cursor-border{position:absolute;top:0;left:0;width:100%;height:100%;border:1px solid var(--selection-bg)}.editor-cursor .editor-cursor-text{position:absolute;top:0;left:0;width:100%;height:100%}.editor-textarea{color:var(--color)}.term-editor-title{color:var(--color);opacity:.7}.term-display-box>div,.term-below-box>div{padding:2px 0;word-break:break-all;white-space:pre-wrap;color:var(--color)}.term-display-box>div a,.term-below-box>div a{opacity:.7}.term-below-box>div{opacity:.7}")), document.head.appendChild(e);
    }
  } catch (o) {
    console.error("vite-plugin-css-injected-by-js", o);
  }
})();
function Q(e, r, i, t, s, c, f) {
  try {
    var d = e[c](f), y = d.value;
  } catch (v2) {
    return void i(v2);
  }
  d.done ? r(y) : Promise.resolve(y).then(t, s);
}
function A(e) {
  return function() {
    var r = this, i = arguments;
    return new Promise(function(t, s) {
      var c = e.apply(r, i);
      function f(y) {
        Q(c, t, s, f, d, "next", y);
      }
      function d(y) {
        Q(c, t, s, f, d, "throw", y);
      }
      f(void 0);
    });
  };
}
function w() {
  w = function() {
    return r;
  };
  var e, r = {}, i = Object.prototype, t = i.hasOwnProperty, s = Object.defineProperty || function(a, n, o) {
    a[n] = o.value;
  }, c = typeof Symbol == "function" ? Symbol : {}, f = c.iterator || "@@iterator", d = c.asyncIterator || "@@asyncIterator", y = c.toStringTag || "@@toStringTag";
  function v2(a, n, o) {
    return Object.defineProperty(a, n, {
      value: o,
      enumerable: true,
      configurable: true,
      writable: true
    }), a[n];
  }
  try {
    v2({}, "");
  } catch {
    v2 = function(n, o, l2) {
      return n[o] = l2;
    };
  }
  function T(a, n, o, l2) {
    var u = n && n.prototype instanceof I2 ? n : I2, h = Object.create(u.prototype), p2 = new R2(l2 || []);
    return s(h, "_invoke", {
      value: _2(a, o, p2)
    }), h;
  }
  function P2(a, n, o) {
    try {
      return {
        type: "normal",
        arg: a.call(n, o)
      };
    } catch (l2) {
      return {
        type: "throw",
        arg: l2
      };
    }
  }
  r.wrap = T;
  var q2 = "suspendedStart", Z2 = "suspendedYield", H2 = "executing", x2 = "completed", b = {};
  function I2() {
  }
  function C() {
  }
  function L2() {
  }
  var N2 = {};
  v2(N2, f, function() {
    return this;
  });
  var S2 = Object.getPrototypeOf, G2 = S2 && S2(S2(U2([])));
  G2 && G2 !== i && t.call(G2, f) && (N2 = G2);
  var j2 = L2.prototype = I2.prototype = Object.create(N2);
  function V2(a) {
    ["next", "throw", "return"].forEach(function(n) {
      v2(a, n, function(o) {
        return this._invoke(n, o);
      });
    });
  }
  function F(a, n) {
    function o(u, h, p2, m2) {
      var g = P2(a[u], a, h);
      if (g.type !== "throw") {
        var O2 = g.arg, k2 = O2.value;
        return k2 && typeof k2 == "object" && t.call(k2, "__await") ? n.resolve(k2.__await).then(function(E2) {
          o("next", E2, p2, m2);
        }, function(E2) {
          o("throw", E2, p2, m2);
        }) : n.resolve(k2).then(function(E2) {
          O2.value = E2, p2(O2);
        }, function(E2) {
          return o("throw", E2, p2, m2);
        });
      }
      m2(g.arg);
    }
    var l2;
    s(this, "_invoke", {
      value: function(u, h) {
        function p2() {
          return new n(function(m2, g) {
            o(u, h, m2, g);
          });
        }
        return l2 = l2 ? l2.then(p2, p2) : p2();
      }
    });
  }
  function _2(a, n, o) {
    var l2 = q2;
    return function(u, h) {
      if (l2 === H2)
        throw Error("Generator is already running");
      if (l2 === x2) {
        if (u === "throw")
          throw h;
        return {
          value: e,
          done: true
        };
      }
      for (o.method = u, o.arg = h; ; ) {
        var p2 = o.delegate;
        if (p2) {
          var m2 = z2(p2, o);
          if (m2) {
            if (m2 === b)
              continue;
            return m2;
          }
        }
        if (o.method === "next")
          o.sent = o._sent = o.arg;
        else if (o.method === "throw") {
          if (l2 === q2)
            throw l2 = x2, o.arg;
          o.dispatchException(o.arg);
        } else
          o.method === "return" && o.abrupt("return", o.arg);
        l2 = H2;
        var g = P2(a, n, o);
        if (g.type === "normal") {
          if (l2 = o.done ? x2 : Z2, g.arg === b)
            continue;
          return {
            value: g.arg,
            done: o.done
          };
        }
        g.type === "throw" && (l2 = x2, o.method = "throw", o.arg = g.arg);
      }
    };
  }
  function z2(a, n) {
    var o = n.method, l2 = a.iterator[o];
    if (l2 === e)
      return n.delegate = null, o === "throw" && a.iterator.return && (n.method = "return", n.arg = e, z2(a, n), n.method === "throw") || o !== "return" && (n.method = "throw", n.arg = new TypeError("The iterator does not provide a '" + o + "' method")), b;
    var u = P2(l2, a.iterator, n.arg);
    if (u.type === "throw")
      return n.method = "throw", n.arg = u.arg, n.delegate = null, b;
    var h = u.arg;
    return h ? h.done ? (n[a.resultName] = h.value, n.next = a.nextLoc, n.method !== "return" && (n.method = "next", n.arg = e), n.delegate = null, b) : h : (n.method = "throw", n.arg = new TypeError("iterator result is not an object"), n.delegate = null, b);
  }
  function ee(a) {
    var n = {
      tryLoc: a[0]
    };
    1 in a && (n.catchLoc = a[1]), 2 in a && (n.finallyLoc = a[2], n.afterLoc = a[3]), this.tryEntries.push(n);
  }
  function B2(a) {
    var n = a.completion || {};
    n.type = "normal", delete n.arg, a.completion = n;
  }
  function R2(a) {
    this.tryEntries = [{
      tryLoc: "root"
    }], a.forEach(ee, this), this.reset(true);
  }
  function U2(a) {
    if (a || a === "") {
      var n = a[f];
      if (n)
        return n.call(a);
      if (typeof a.next == "function")
        return a;
      if (!isNaN(a.length)) {
        var o = -1, l2 = function u() {
          for (; ++o < a.length; )
            if (t.call(a, o))
              return u.value = a[o], u.done = false, u;
          return u.value = e, u.done = true, u;
        };
        return l2.next = l2;
      }
    }
    throw new TypeError(typeof a + " is not iterable");
  }
  return C.prototype = L2, s(j2, "constructor", {
    value: L2,
    configurable: true
  }), s(L2, "constructor", {
    value: C,
    configurable: true
  }), C.displayName = v2(L2, y, "GeneratorFunction"), r.isGeneratorFunction = function(a) {
    var n = typeof a == "function" && a.constructor;
    return !!n && (n === C || (n.displayName || n.name) === "GeneratorFunction");
  }, r.mark = function(a) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(a, L2) : (a.__proto__ = L2, v2(a, y, "GeneratorFunction")), a.prototype = Object.create(j2), a;
  }, r.awrap = function(a) {
    return {
      __await: a
    };
  }, V2(F.prototype), v2(F.prototype, d, function() {
    return this;
  }), r.AsyncIterator = F, r.async = function(a, n, o, l2, u) {
    u === void 0 && (u = Promise);
    var h = new F(T(a, n, o, l2), u);
    return r.isGeneratorFunction(n) ? h : h.next().then(function(p2) {
      return p2.done ? p2.value : h.next();
    });
  }, V2(j2), v2(j2, y, "Generator"), v2(j2, f, function() {
    return this;
  }), v2(j2, "toString", function() {
    return "[object Generator]";
  }), r.keys = function(a) {
    var n = Object(a), o = [];
    for (var l2 in n)
      o.push(l2);
    return o.reverse(), function u() {
      for (; o.length; ) {
        var h = o.pop();
        if (h in n)
          return u.value = h, u.done = false, u;
      }
      return u.done = true, u;
    };
  }, r.values = U2, R2.prototype = {
    constructor: R2,
    reset: function(a) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = false, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(B2), !a)
        for (var n in this)
          n.charAt(0) === "t" && t.call(this, n) && !isNaN(+n.slice(1)) && (this[n] = e);
    },
    stop: function() {
      this.done = true;
      var a = this.tryEntries[0].completion;
      if (a.type === "throw")
        throw a.arg;
      return this.rval;
    },
    dispatchException: function(a) {
      if (this.done)
        throw a;
      var n = this;
      function o(g, O2) {
        return h.type = "throw", h.arg = a, n.next = g, O2 && (n.method = "next", n.arg = e), !!O2;
      }
      for (var l2 = this.tryEntries.length - 1; l2 >= 0; --l2) {
        var u = this.tryEntries[l2], h = u.completion;
        if (u.tryLoc === "root")
          return o("end");
        if (u.tryLoc <= this.prev) {
          var p2 = t.call(u, "catchLoc"), m2 = t.call(u, "finallyLoc");
          if (p2 && m2) {
            if (this.prev < u.catchLoc)
              return o(u.catchLoc, true);
            if (this.prev < u.finallyLoc)
              return o(u.finallyLoc);
          } else if (p2) {
            if (this.prev < u.catchLoc)
              return o(u.catchLoc, true);
          } else {
            if (!m2)
              throw Error("try statement without catch or finally");
            if (this.prev < u.finallyLoc)
              return o(u.finallyLoc);
          }
        }
      }
    },
    abrupt: function(a, n) {
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var l2 = this.tryEntries[o];
        if (l2.tryLoc <= this.prev && t.call(l2, "finallyLoc") && this.prev < l2.finallyLoc) {
          var u = l2;
          break;
        }
      }
      u && (a === "break" || a === "continue") && u.tryLoc <= n && n <= u.finallyLoc && (u = null);
      var h = u ? u.completion : {};
      return h.type = a, h.arg = n, u ? (this.method = "next", this.next = u.finallyLoc, b) : this.complete(h);
    },
    complete: function(a, n) {
      if (a.type === "throw")
        throw a.arg;
      return a.type === "break" || a.type === "continue" ? this.next = a.arg : a.type === "return" ? (this.rval = this.arg = a.arg, this.method = "return", this.next = "end") : a.type === "normal" && n && (this.next = n), b;
    },
    finish: function(a) {
      for (var n = this.tryEntries.length - 1; n >= 0; --n) {
        var o = this.tryEntries[n];
        if (o.finallyLoc === a)
          return this.complete(o.completion, o.afterLoc), B2(o), b;
      }
    },
    catch: function(a) {
      for (var n = this.tryEntries.length - 1; n >= 0; --n) {
        var o = this.tryEntries[n];
        if (o.tryLoc === a) {
          var l2 = o.completion;
          if (l2.type === "throw") {
            var u = l2.arg;
            B2(o);
          }
          return u;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(a, n, o) {
      return this.delegate = {
        iterator: U2(a),
        resultName: n,
        nextLoc: o
      }, this.method === "next" && (this.arg = e), b;
    }
  }, r;
}
function ue$1() {
  var e, r, i = new Promise(function(t, s) {
    e = t, r = s;
  });
  return {
    ready: i,
    resolve: e,
    reject: r
  };
}
function ve$1() {
  for (var e = 0, r = arguments.length, i = new Array(r), t = 0; t < r; t++)
    i[t] = arguments[t];
  for (var s = 0, c = i; s < c.length; s++) {
    var f = c[s];
    e += f.length;
  }
  for (var d = new Uint8Array(e), y = 0, v2 = 0, T = i; v2 < T.length; v2++) {
    var P2 = T[v2];
    d.set(P2, y), y += P2.length;
  }
  return d;
}
function ye(e, r) {
  if (!e || !r)
    return false;
  var i = e.byteLength;
  if (i !== r.byteLength)
    return false;
  for (var t = 0; t < i; t++)
    if (e[t] !== r[t])
      return false;
  return true;
}
function de$1(e) {
  return new Uint8Array(e);
}
function me(e) {
  return $.apply(this, arguments);
}
function $() {
  return $ = A(/* @__PURE__ */ w().mark(function e(r) {
    return w().wrap(function(t) {
      for (; ; )
        switch (t.prev = t.next) {
          case 0:
            return t.prev = 0, t.next = 3, r;
          case 3:
            return t.t0 = t.sent, t.abrupt("return", [t.t0, null]);
          case 7:
            return t.prev = 7, t.t1 = t.catch(0), t.abrupt("return", [{}, t.t1]);
          case 10:
          case "end":
            return t.stop();
        }
    }, e, null, [[0, 7]]);
  })), $.apply(this, arguments);
}
var M$1;
function ge$1(e) {
  return M$1 || (M$1 = new TextEncoder()), M$1.encode(e);
}
var D;
function we$1(e) {
  return D || (D = new TextDecoder()), D.decode(e);
}
function be(e) {
  return J$2.apply(this, arguments);
}
function J$2() {
  return J$2 = A(/* @__PURE__ */ w().mark(function e(r) {
    var i;
    return w().wrap(function(s) {
      for (; ; )
        switch (s.prev = s.next) {
          case 0:
            i = 0;
          case 1:
            if (!(i < r.length)) {
              s.next = 7;
              break;
            }
            return s.next = 4, r[i]();
          case 4:
            i++, s.next = 1;
            break;
          case 7:
          case "end":
            return s.stop();
        }
    }, e);
  })), J$2.apply(this, arguments);
}
function Le$1() {
  var e = [];
  return {
    add: function(i) {
      e.push(i);
    },
    run: function() {
      return Promise.all(e);
    }
  };
}
function ce$1(e) {
  if (e === "/")
    return {
      path: e,
      parent: e,
      name: ""
    };
  if (e.endsWith("/"))
    return ce$1(e.substring(0, e.length - 1));
  var r = e.lastIndexOf("/");
  return r === -1 ? {
    path: e,
    parent: "",
    name: e
  } : {
    path: e,
    parent: e.substring(0, r) || "/",
    name: e.substring(r + 1)
  };
}
var se = {
  "\r": "Enter",
  "": "Backspace",
  "\x1B[A": "Up",
  "\x1B[B": "Down",
  "\x1B[D": "Left",
  "\x1B[C": "Right",
  "	": "Tab"
}, le$1 = Object.values(se);
new Set(le$1);
function assertPath(path) {
  if (typeof path !== "string") {
    throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
  }
}
function normalizeStringPosix(path, allowAboveRoot) {
  var res = "";
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code2;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code2 = path.charCodeAt(i);
    else if (code2 === 47)
      break;
    else
      code2 = 47;
    if (code2 === 47) {
      if (lastSlash === i - 1 || dots === 1)
        ;
      else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += "/..";
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += "/" + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code2 === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}
var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = "";
    var resolvedAbsolute = false;
    var cwd;
    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === void 0)
          cwd = process.cwd();
        path = cwd;
      }
      assertPath(path);
      if (path.length === 0) {
        continue;
      }
      resolvedPath = path + "/" + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return "/" + resolvedPath;
      else
        return "/";
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return ".";
    }
  },
  normalize: function normalize(path) {
    assertPath(path);
    if (path.length === 0)
      return ".";
    var isAbsolute2 = path.charCodeAt(0) === 47;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeStringPosix(path, !isAbsolute2);
    if (path.length === 0 && !isAbsolute2)
      path = ".";
    if (path.length > 0 && trailingSeparator)
      path += "/";
    if (isAbsolute2)
      return "/" + path;
    return path;
  },
  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
  },
  join: function join() {
    if (arguments.length === 0)
      return ".";
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === void 0)
          joined = arg;
        else
          joined += "/" + arg;
      }
    }
    if (joined === void 0)
      return ".";
    return posix.normalize(joined);
  },
  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to)
      return "";
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to)
      return "";
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47)
        lastCommonSep = i;
    }
    var out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0)
          out += "..";
        else
          out += "/..";
      }
    }
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47)
        ++toStart;
      return to.slice(toStart);
    }
  },
  _makeLong: function _makeLong(path) {
    return path;
  },
  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0)
      return ".";
    var code2 = path.charCodeAt(0);
    var hasRoot = code2 === 47;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end === -1)
      return hasRoot ? "/" : ".";
    if (hasRoot && end === 1)
      return "//";
    return path.slice(0, end);
  },
  basename: function basename(path, ext) {
    if (ext !== void 0 && typeof ext !== "string")
      throw new TypeError('"ext" argument must be a string');
    assertPath(path);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path)
        return "";
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code2 = path.charCodeAt(i);
        if (code2 === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code2 === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end = i;
              }
            } else {
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end)
        end = firstNonSlashEnd;
      else if (end === -1)
        end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1)
        return "";
      return path.slice(start, end);
    }
  },
  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end);
  },
  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  },
  parse: function parse(path) {
    assertPath(path);
    var ret = { root: "", dir: "", base: "", ext: "", name: "" };
    if (path.length === 0)
      return ret;
    var code2 = path.charCodeAt(0);
    var isAbsolute2 = code2 === 47;
    var start;
    if (isAbsolute2) {
      ret.root = "/";
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;
    var preDotState = 0;
    for (; i >= start; --i) {
      code2 = path.charCodeAt(i);
      if (code2 === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        matchedSlash = false;
        end = i + 1;
      }
      if (code2 === 46) {
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute2)
          ret.base = ret.name = path.slice(1, end);
        else
          ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute2) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0)
      ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute2)
      ret.dir = "/";
    return ret;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.posix = posix;
var pathBrowserify = posix;
const index = /* @__PURE__ */ getDefaultExportFromCjs(pathBrowserify);
const _e = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index
}, [pathBrowserify]);
var jszip_min = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(module2, exports2) {
  !function(e) {
    module2.exports = e();
  }(function() {
    return function s(a, o, h) {
      function u(r, e2) {
        if (!o[r]) {
          if (!a[r]) {
            var t = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e2 && t)
              return t(r, true);
            if (l2)
              return l2(r, true);
            var n = new Error("Cannot find module '" + r + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          }
          var i = o[r] = { exports: {} };
          a[r][0].call(i.exports, function(e3) {
            var t2 = a[r][1][e3];
            return u(t2 || e3);
          }, i, i.exports, s, a, o, h);
        }
        return o[r].exports;
      }
      for (var l2 = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++)
        u(h[e]);
      return u;
    }({ 1: [function(e, t, r) {
      var d = e("./utils"), c = e("./support"), p2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(e2) {
        for (var t2, r2, n, i, s, a, o, h = [], u = 0, l2 = e2.length, f = l2, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
          f = l2 - u, n = c2 ? (t2 = e2[u++], r2 = u < l2 ? e2[u++] : 0, u < l2 ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l2 ? e2.charCodeAt(u++) : 0, u < l2 ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p2.charAt(i) + p2.charAt(s) + p2.charAt(a) + p2.charAt(o));
        return h.join("");
      }, r.decode = function(e2) {
        var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
        if (e2.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l2, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (e2.charAt(e2.length - 1) === p2.charAt(64) && f--, e2.charAt(e2.length - 2) === p2.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l2 = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
          t2 = p2.indexOf(e2.charAt(o++)) << 2 | (i = p2.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p2.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p2.indexOf(e2.charAt(o++))), l2[h++] = t2, 64 !== s && (l2[h++] = r2), 64 !== a && (l2[h++] = n);
        return l2;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
      var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
      function o(e2, t2, r2, n2, i2) {
        this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
      }
      o.prototype = { getContentWorker: function() {
        var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
        return e2.on("end", function() {
          if (this.streamInfo.data_length !== t2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e2;
      }, getCompressedWorker: function() {
        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(e2, t2, r2) {
        return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
      }, t.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
      var n = e("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
      var n = e("./utils");
      var o = function() {
        for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
          e2 = r2;
          for (var n2 = 0; n2 < 8; n2++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2) {
        return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, t, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, t, r) {
      var n = null;
      n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
      function h(e2, t2) {
        a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
      }
      r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
        this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t2 = this;
        this._pako.onData = function(e2) {
          t2.push({ data: e2, meta: t2.meta });
        };
      }, r.compressWorker = function(e2) {
        return new h("Deflate", e2);
      }, r.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
      function A2(e2, t2) {
        var r2, n2 = "";
        for (r2 = 0; r2 < t2; r2++)
          n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
        return n2;
      }
      function n(e2, t2, r2, n2, i2, s2) {
        var a, o, h = e2.file, u = e2.compression, l2 = s2 !== O2.utf8encode, f = I2.transformTo("string", s2(h.name)), c = I2.transformTo("string", O2.utf8encode(h.name)), d = h.comment, p2 = I2.transformTo("string", s2(d)), m2 = I2.transformTo("string", O2.utf8encode(d)), _2 = c.length !== h.name.length, g = m2.length !== d.length, b = "", v2 = "", y = "", w2 = h.dir, k2 = h.date, x2 = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t2 && !r2 || (x2.crc32 = e2.crc32, x2.compressedSize = e2.compressedSize, x2.uncompressedSize = e2.uncompressedSize);
        var S2 = 0;
        t2 && (S2 |= 8), l2 || !_2 && !g || (S2 |= 2048);
        var z2 = 0, C = 0;
        w2 && (z2 |= 16), "UNIX" === i2 ? (C = 798, z2 |= function(e3, t3) {
          var r3 = e3;
          return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
        }(h.unixPermissions, w2)) : (C = 20, z2 |= function(e3) {
          return 63 & (e3 || 0);
        }(h.dosPermissions)), a = k2.getUTCHours(), a <<= 6, a |= k2.getUTCMinutes(), a <<= 5, a |= k2.getUTCSeconds() / 2, o = k2.getUTCFullYear() - 1980, o <<= 4, o |= k2.getUTCMonth() + 1, o <<= 5, o |= k2.getUTCDate(), _2 && (v2 = A2(1, 1) + A2(B2(f), 4) + c, b += "up" + A2(v2.length, 2) + v2), g && (y = A2(1, 1) + A2(B2(p2), 4) + m2, b += "uc" + A2(y.length, 2) + y);
        var E2 = "";
        return E2 += "\n\0", E2 += A2(S2, 2), E2 += u.magic, E2 += A2(a, 2), E2 += A2(o, 2), E2 += A2(x2.crc32, 4), E2 += A2(x2.compressedSize, 4), E2 += A2(x2.uncompressedSize, 4), E2 += A2(f.length, 2), E2 += A2(b.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E2 + f + b, dirRecord: R2.CENTRAL_FILE_HEADER + A2(C, 2) + E2 + A2(p2.length, 2) + "\0\0\0\0" + A2(z2, 4) + A2(n2, 4) + f + b + p2 };
      }
      var I2 = e("../utils"), i = e("../stream/GenericWorker"), O2 = e("../utf8"), B2 = e("../crc32"), R2 = e("../signature");
      function s(e2, t2, r2, n2) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I2.inherits(s, i), s.prototype.push = function(e2) {
        var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(e2) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
        var t2 = this.streamFiles && !e2.file.dir;
        if (t2) {
          var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(e2) {
        this.accumulate = false;
        var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), t2)
          this.push({ data: function(e3) {
            return R2.DATA_DESCRIPTOR + A2(e3.crc32, 4) + A2(e3.compressedSize, 4) + A2(e3.uncompressedSize, 4);
          }(e2), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
          this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
          var s2 = I2.transformTo("string", i2(n3));
          return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A2(e3, 2) + A2(e3, 2) + A2(t3, 4) + A2(r3, 4) + A2(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
        this.push({ data: n2, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(e2) {
        this._sources.push(e2);
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s.prototype.error = function(e2) {
        var t2 = this._sources;
        if (!i.prototype.error.call(this, e2))
          return false;
        for (var r2 = 0; r2 < t2.length; r2++)
          try {
            t2[r2].error(e2);
          } catch (e3) {
          }
        return true;
      }, s.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
          e2[t2].lock();
      }, t.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
      var u = e("../compressions"), n = e("./ZipFileWorker");
      r.generateWorker = function(e2, a, t2) {
        var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
        try {
          e2.forEach(function(e3, t3) {
            h++;
            var r2 = function(e4, t4) {
              var r3 = e4 || t4, n3 = u[r3];
              if (!n3)
                throw new Error(r3 + " is not a valid compression method !");
              return n3;
            }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
            t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
          }), o.entriesCount = h;
        } catch (e3) {
          o.error(e3);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e2 = new n();
          for (var t2 in this)
            "function" != typeof this[t2] && (e2[t2] = this[t2]);
          return e2;
        };
      }
      (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
        return new n().loadAsync(e2, t2);
      }, n.external = e("./external"), t.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
      var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l2 = e("./nodejsUtils");
      function f(n2) {
        return new i.Promise(function(e2, t2) {
          var r2 = n2.decompressed.getContentWorker().pipe(new a());
          r2.on("error", function(e3) {
            t2(e3);
          }).on("end", function() {
            r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
          }).resume();
        });
      }
      t.exports = function(e2, o) {
        var h = this;
        return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l2.isNode && l2.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
          var t2 = new s(o);
          return t2.load(e3), t2;
        }).then(function(e3) {
          var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
          if (o.checkCRC32)
            for (var n2 = 0; n2 < r2.length; n2++)
              t2.push(f(r2[n2]));
          return i.Promise.all(t2);
        }).then(function(e3) {
          for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
            var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
            h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
          }
          return t2.zipComment.length && (h.comment = t2.zipComment), h;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
      var n = e("../utils"), i = e("../stream/GenericWorker");
      function s(e2, t2) {
        i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
      }
      n.inherits(s, i), s.prototype._bindStream = function(e2) {
        var t2 = this;
        (this._stream = e2).pause(), e2.on("data", function(e3) {
          t2.push({ data: e3, meta: { percent: 0 } });
        }).on("error", function(e3) {
          t2.isPaused ? this.generatedError = e3 : t2.error(e3);
        }).on("end", function() {
          t2.isPaused ? t2._upstreamEnded = true : t2.end();
        });
      }, s.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
      var i = e("readable-stream").Readable;
      function n(e2, t2, r2) {
        i.call(this, t2), this._helper = e2;
        var n2 = this;
        e2.on("data", function(e3, t3) {
          n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
        }).on("error", function(e3) {
          n2.emit("error", e3);
        }).on("end", function() {
          n2.push(null);
        });
      }
      e("../utils").inherits(n, i), n.prototype._read = function() {
        this._helper.resume();
      }, t.exports = n;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
      t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e2, t2);
        if ("number" == typeof e2)
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e2, t2);
      }, allocBuffer: function(e2) {
        if (Buffer.alloc)
          return Buffer.alloc(e2);
        var t2 = new Buffer(e2);
        return t2.fill(0), t2;
      }, isBuffer: function(e2) {
        return Buffer.isBuffer(e2);
      }, isStream: function(e2) {
        return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
      } };
    }, {}], 15: [function(e, t, r) {
      function s(e2, t2, r2) {
        var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _2(e2)) && b.call(this, n2, true);
        var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
        r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
        var o2 = null;
        o2 = t2 instanceof c || t2 instanceof l2 ? t2 : p2.isNode && p2.isStream(t2) ? new m2(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h2 = new d(e2, o2, s2);
        this.files[e2] = h2;
      }
      var i = e("./utf8"), u = e("./utils"), l2 = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p2 = e("./nodejsUtils"), m2 = e("./nodejs/NodejsStreamInputAdapter"), _2 = function(e2) {
        "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
        var t2 = e2.lastIndexOf("/");
        return 0 < t2 ? e2.substring(0, t2) : "";
      }, g = function(e2) {
        return "/" !== e2.slice(-1) && (e2 += "/"), e2;
      }, b = function(e2, t2) {
        return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
      };
      function h(e2) {
        return "[object RegExp]" === Object.prototype.toString.call(e2);
      }
      var n = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e2) {
        var t2, r2, n2;
        for (t2 in this.files)
          n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
      }, filter: function(r2) {
        var n2 = [];
        return this.forEach(function(e2, t2) {
          r2(e2, t2) && n2.push(t2);
        }), n2;
      }, file: function(e2, t2, r2) {
        if (1 !== arguments.length)
          return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
        if (h(e2)) {
          var n2 = e2;
          return this.filter(function(e3, t3) {
            return !t3.dir && n2.test(e3);
          });
        }
        var i2 = this.files[this.root + e2];
        return i2 && !i2.dir ? i2 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h(r2))
          return this.filter(function(e3, t3) {
            return t3.dir && r2.test(e3);
          });
        var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
        return n2.root = t2.name, n2;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var e2 = this.files[r2];
        if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
          delete this.files[r2];
        else
          for (var t2 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t2.length; n2++)
            delete this.files[t2[n2].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e2) {
        var t2, r2 = {};
        try {
          if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
          var n2 = r2.comment || this.comment || "";
          t2 = o.generateWorker(this, r2, n2);
        } catch (e3) {
          (t2 = new l2("error")).error(e3);
        }
        return new a(t2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(e2, t2) {
        return this.generateInternalStream(e2).accumulate(t2);
      }, generateNodeStream: function(e2, t2) {
        return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
      } };
      t.exports = n;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
      t.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
        for (var t2 = 0; t2 < this.data.length; t2++)
          e2[t2] = 255 & e2[t2];
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data[this.zero + e2];
      }, i.prototype.lastIndexOfSignature = function(e2) {
        for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
          if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
            return s - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(e2) {
        var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
        return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
      }, i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), 0 === e2)
          return [];
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
      var n = e("../utils");
      function i(e2) {
        this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(e2) {
        this.checkIndex(this.index + e2);
      }, checkIndex: function(e2) {
        if (this.length < this.zero + e2 || e2 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
      }, setIndex: function(e2) {
        this.checkIndex(e2), this.index = e2;
      }, skip: function(e2) {
        this.setIndex(this.index + e2);
      }, byteAt: function() {
      }, readInt: function(e2) {
        var t2, r2 = 0;
        for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
          r2 = (r2 << 8) + this.byteAt(t2);
        return this.index += e2, r2;
      }, readString: function(e2) {
        return n.transformTo("string", this.readData(e2));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var e2 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
      } }, t.exports = i;
    }, { "../utils": 32 }], 19: [function(e, t, r) {
      var n = e("./Uint8ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data.charCodeAt(this.zero + e2);
      }, i.prototype.lastIndexOfSignature = function(e2) {
        return this.data.lastIndexOf(e2) - this.zero;
      }, i.prototype.readAndCheckSignature = function(e2) {
        return e2 === this.readData(4);
      }, i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
      var n = e("./ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), 0 === e2)
          return new Uint8Array(0);
        var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
      var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      t.exports = function(e2) {
        var t2 = n.getTypeOf(e2);
        return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../utils");
      function s(e2) {
        n.call(this, "ConvertWorker to " + e2), this.destType = e2;
      }
      i.inherits(s, n), s.prototype.processChunk = function(e2) {
        this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../crc32");
      function s() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
        this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
      }, t.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
      }
      n.inherits(s, i), s.prototype.processChunk = function(e2) {
        if (e2) {
          var t2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t2 + e2.data.length;
        }
        i.prototype.processChunk.call(this, e2);
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataWorker");
        var t2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
          t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
        }, function(e3) {
          t2.error(e3);
        });
      }
      n.inherits(s, i), s.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e2 = null, t2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e2 = this.data.substring(this.index, t2);
            break;
          case "uint8array":
            e2 = this.data.subarray(this.index, t2);
            break;
          case "array":
          case "nodebuffer":
            e2 = this.data.slice(this.index, t2);
        }
        return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
      function n(e2) {
        this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(e2) {
        this.emit("data", e2);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e2) {
          this.emit("error", e2);
        }
        return true;
      }, error: function(e2) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
      }, on: function(e2, t2) {
        return this._listeners[e2].push(t2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e2, t2) {
        if (this._listeners[e2])
          for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
            this._listeners[e2][r2].call(this, t2);
      }, pipe: function(e2) {
        return e2.registerPrevious(this);
      }, registerPrevious: function(e2) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e2 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
      }, flush: function() {
      }, processChunk: function(e2) {
        this.push(e2);
      }, withStreamInfo: function(e2, t2) {
        return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e2 in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e2 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e2 : e2;
      } }, t.exports = n;
    }, {}], 29: [function(e, t, r) {
      var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
      if (n.nodestream)
        try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {
        }
      function l2(e2, o2) {
        return new a.Promise(function(t2, r2) {
          var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
          e2.on("data", function(e3, t3) {
            n2.push(e3), o2 && o2(t3);
          }).on("error", function(e3) {
            n2 = [], r2(e3);
          }).on("end", function() {
            try {
              var e3 = function(e4, t3, r3) {
                switch (e4) {
                  case "blob":
                    return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                  case "base64":
                    return u.encode(t3);
                  default:
                    return h.transformTo(e4, t3);
                }
              }(s2, function(e4, t3) {
                var r3, n3 = 0, i3 = null, s3 = 0;
                for (r3 = 0; r3 < t3.length; r3++)
                  s3 += t3[r3].length;
                switch (e4) {
                  case "string":
                    return t3.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t3);
                  case "uint8array":
                    for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                      i3.set(t3[r3], n3), n3 += t3[r3].length;
                    return i3;
                  case "nodebuffer":
                    return Buffer.concat(t3);
                  default:
                    throw new Error("concat : unsupported type '" + e4 + "'");
                }
              }(i2, n2), a2);
              t2(e3);
            } catch (e4) {
              r2(e4);
            }
            n2 = [];
          }).resume();
        });
      }
      function f(e2, t2, r2) {
        var n2 = t2;
        switch (t2) {
          case "blob":
          case "arraybuffer":
            n2 = "uint8array";
            break;
          case "base64":
            n2 = "string";
        }
        try {
          this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
        } catch (e3) {
          this._worker = new s("error"), this._worker.error(e3);
        }
      }
      f.prototype = { accumulate: function(e2) {
        return l2(this, e2);
      }, on: function(e2, t2) {
        var r2 = this;
        return "data" === e2 ? this._worker.on(e2, function(e3) {
          t2.call(r2, e3.data, e3.meta);
        }) : this._worker.on(e2, function() {
          h.delay(t2, arguments, r2);
        }), this;
      }, resume: function() {
        return h.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e2) {
        if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
      } }, t.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
        r.blob = false;
      else {
        var n = new ArrayBuffer(0);
        try {
          r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
        } catch (e2) {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
          } catch (e3) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch (e2) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e, t, s) {
      for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
        u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        n.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l2() {
        n.call(this, "utf-8 encode");
      }
      s.utf8encode = function(e2) {
        return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
          var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
          for (i2 = 0; i2 < a2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }(e2);
      }, s.utf8decode = function(e2) {
        return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
          var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
          for (t2 = r2 = 0; t2 < s2; )
            if ((n2 = e3[t2++]) < 128)
              a2[r2++] = n2;
            else if (4 < (i2 = u[n2]))
              a2[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                n2 = n2 << 6 | 63 & e3[t2++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
      }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
        var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
        if (this.leftOver && this.leftOver.length) {
          if (h.uint8array) {
            var r2 = t2;
            (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
          } else
            t2 = this.leftOver.concat(t2);
          this.leftOver = null;
        }
        var n2 = function(e3, t3) {
          var r3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
            r3--;
          return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
        }(t2), i2 = t2;
        n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l2, n), l2.prototype.processChunk = function(e2) {
        this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
      }, s.Utf8EncodeWorker = l2;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
      var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
      function n(e2) {
        return e2;
      }
      function l2(e2, t2) {
        for (var r2 = 0; r2 < e2.length; ++r2)
          t2[r2] = 255 & e2.charCodeAt(r2);
        return t2;
      }
      e("setimmediate"), a.newBlob = function(t2, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([t2], { type: r2 });
        } catch (e2) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n2.append(t2), n2.getBlob(r2);
          } catch (e3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i = { stringifyByChunk: function(e2, t2, r2) {
        var n2 = [], i2 = 0, s2 = e2.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, e2);
        for (; i2 < s2; )
          "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
        return n2.join("");
      }, stringifyByChar: function(e2) {
        for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
          t2 += String.fromCharCode(e2[r2]);
        return t2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
        } catch (e2) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
        } catch (e2) {
          return false;
        }
      }() } };
      function s(e2) {
        var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
        if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
          for (; 1 < t2; )
            try {
              return i.stringifyByChunk(e2, r2, t2);
            } catch (e3) {
              t2 = Math.floor(t2 / 2);
            }
        return i.stringifyByChar(e2);
      }
      function f(e2, t2) {
        for (var r2 = 0; r2 < e2.length; r2++)
          t2[r2] = e2[r2];
        return t2;
      }
      a.applyFromCharCode = s;
      var c = {};
      c.string = { string: n, array: function(e2) {
        return l2(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.string.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return l2(e2, new Uint8Array(e2.length));
      }, nodebuffer: function(e2) {
        return l2(e2, r.allocBuffer(e2.length));
      } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
        return new Uint8Array(e2).buffer;
      }, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.arraybuffer = { string: function(e2) {
        return s(new Uint8Array(e2));
      }, array: function(e2) {
        return f(new Uint8Array(e2), new Array(e2.byteLength));
      }, arraybuffer: n, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(new Uint8Array(e2));
      } }, c.uint8array = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return e2.buffer;
      }, uint8array: n, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.nodebuffer = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.nodebuffer.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return f(e2, new Uint8Array(e2.length));
      }, nodebuffer: n }, a.transformTo = function(e2, t2) {
        if (t2 = t2 || "", !e2)
          return t2;
        a.checkSupport(e2);
        var r2 = a.getTypeOf(t2);
        return c[r2][e2](t2);
      }, a.resolve = function(e2) {
        for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2];
          "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
        }
        return r2.join("/");
      }, a.getTypeOf = function(e2) {
        return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(e2) {
        if (!o[e2.toLowerCase()])
          throw new Error(e2 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
        var t2, r2, n2 = "";
        for (r2 = 0; r2 < (e2 || "").length; r2++)
          n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
        return n2;
      }, a.delay = function(e2, t2, r2) {
        setImmediate(function() {
          e2.apply(r2 || null, t2 || []);
        });
      }, a.inherits = function(e2, t2) {
        function r2() {
        }
        r2.prototype = t2.prototype, e2.prototype = new r2();
      }, a.extend = function() {
        var e2, t2, r2 = {};
        for (e2 = 0; e2 < arguments.length; e2++)
          for (t2 in arguments[e2])
            Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
        return r2;
      }, a.prepareContent = function(r2, e2, n2, i2, s2) {
        return u.Promise.resolve(e2).then(function(n3) {
          return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
            var e3 = new FileReader();
            e3.onload = function(e4) {
              t2(e4.target.result);
            }, e3.onerror = function(e4) {
              r3(e4.target.error);
            }, e3.readAsArrayBuffer(n3);
          }) : n3;
        }).then(function(e3) {
          var t2 = a.getTypeOf(e3);
          return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
            return l2(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
          }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
      var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
      function h(e2) {
        this.files = [], this.loadOptions = e2;
      }
      h.prototype = { checkSignature: function(e2) {
        if (!this.reader.readAndCheckSignature(e2)) {
          this.reader.index -= 4;
          var t2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
        }
      }, isSignature: function(e2, t2) {
        var r2 = this.reader.index;
        this.reader.setIndex(e2);
        var n2 = this.reader.readString(4) === t2;
        return this.reader.setIndex(r2), n2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
          e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e2, t2;
        for (e2 = 0; e2 < this.files.length; e2++)
          t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
      }, readCentralDir: function() {
        var e2;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (e2 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e2);
        var t2 = e2;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var n2 = t2 - r2;
        if (0 < n2)
          this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
        else if (n2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
      }, prepareReader: function(e2) {
        this.reader = n(e2);
      }, load: function(e2) {
        this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
      var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
      function l2(e2, t2) {
        this.options = e2, this.loadOptions = t2;
      }
      l2.prototype = { isEncrypted: function() {
        return 1 == (1 & this.bitFlag);
      }, useUTF8: function() {
        return 2048 == (2048 & this.bitFlag);
      }, readLocalPart: function(e2) {
        var t2, r2;
        if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if (null === (t2 = function(e3) {
          for (var t3 in h)
            if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
              return h[t3];
          return null;
        }(this.compressionMethod)))
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
      }, readCentralPart: function(e2) {
        this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
        var t2 = e2.readInt(2);
        if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e2 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var e2 = n(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
        }
      }, readExtraFields: function(e2) {
        var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
          t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
        e2.setIndex(i2);
      }, handleUTF8: function() {
        var e2 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var t2 = this.findExtraFieldUnicodePath();
          if (null !== t2)
            this.fileNameStr = t2;
          else {
            var r2 = s.transformTo(e2, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var n2 = this.findExtraFieldUnicodeComment();
          if (null !== n2)
            this.fileCommentStr = n2;
          else {
            var i2 = s.transformTo(e2, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e2 = this.extraFields[28789];
        if (e2) {
          var t2 = n(e2.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e2 = this.extraFields[25461];
        if (e2) {
          var t2 = n(e2.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      } }, t.exports = l2;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
      function n(e2, t2, r2) {
        this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
      n.prototype = { internalStream: function(e2) {
        var t2 = null, r2 = "string";
        try {
          if (!e2)
            throw new Error("No output type specified.");
          var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
          "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
          var i2 = !this._dataBinary;
          i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
        } catch (e3) {
          (t2 = new h("error")).error(e3);
        }
        return new s(t2, r2, "");
      }, async: function(e2, t2) {
        return this.internalStream(e2).accumulate(t2);
      }, nodeStream: function(e2, t2) {
        return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
      }, _compressWorker: function(e2, t2) {
        if (this._data instanceof o && this._data.compression.magic === e2.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l2 = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < u.length; f++)
        n.prototype[u[f]] = l2;
      t.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l2, t) {
      (function(t2) {
        var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
        if (e2) {
          var i = 0, s = new e2(u), a = t2.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = i = ++i % 2;
          };
        } else if (t2.setImmediate || void 0 === t2.MessageChannel)
          r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e3 = t2.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t2.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new t2.MessageChannel();
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var e3, t3;
          n = true;
          for (var r2 = h.length; r2; ) {
            for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
              t3[e3]();
            r2 = h.length;
          }
          n = false;
        }
        l2.exports = function(e3) {
          1 !== h.push(e3) || n || r();
        };
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 37: [function(e, t, r) {
      var i = e("immediate");
      function u() {
      }
      var l2 = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
      function o(e2) {
        if ("function" != typeof e2)
          throw new TypeError("resolver must be a function");
        this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
      }
      function h(e2, t2, r2) {
        this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(t2, r2, n2) {
        i(function() {
          var e2;
          try {
            e2 = r2(n2);
          } catch (e3) {
            return l2.reject(t2, e3);
          }
          e2 === t2 ? l2.reject(t2, new TypeError("Cannot resolve promise with itself")) : l2.resolve(t2, e2);
        });
      }
      function c(e2) {
        var t2 = e2 && e2.then;
        if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
          return function() {
            t2.apply(e2, arguments);
          };
      }
      function d(t2, e2) {
        var r2 = false;
        function n2(e3) {
          r2 || (r2 = true, l2.reject(t2, e3));
        }
        function i2(e3) {
          r2 || (r2 = true, l2.resolve(t2, e3));
        }
        var s2 = p2(function() {
          e2(i2, n2);
        });
        "error" === s2.status && n2(s2.value);
      }
      function p2(e2, t2) {
        var r2 = {};
        try {
          r2.value = e2(t2), r2.status = "success";
        } catch (e3) {
          r2.status = "error", r2.value = e3;
        }
        return r2;
      }
      (t.exports = o).prototype.finally = function(t2) {
        if ("function" != typeof t2)
          return this;
        var r2 = this.constructor;
        return this.then(function(e2) {
          return r2.resolve(t2()).then(function() {
            return e2;
          });
        }, function(e2) {
          return r2.resolve(t2()).then(function() {
            throw e2;
          });
        });
      }, o.prototype.catch = function(e2) {
        return this.then(null, e2);
      }, o.prototype.then = function(e2, t2) {
        if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
        return r2;
      }, h.prototype.callFulfilled = function(e2) {
        l2.resolve(this.promise, e2);
      }, h.prototype.otherCallFulfilled = function(e2) {
        f(this.promise, this.onFulfilled, e2);
      }, h.prototype.callRejected = function(e2) {
        l2.reject(this.promise, e2);
      }, h.prototype.otherCallRejected = function(e2) {
        f(this.promise, this.onRejected, e2);
      }, l2.resolve = function(e2, t2) {
        var r2 = p2(c, t2);
        if ("error" === r2.status)
          return l2.reject(e2, r2.value);
        var n2 = r2.value;
        if (n2)
          d(e2, n2);
        else {
          e2.state = a, e2.outcome = t2;
          for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
            e2.queue[i2].callFulfilled(t2);
        }
        return e2;
      }, l2.reject = function(e2, t2) {
        e2.state = s, e2.outcome = t2;
        for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
          e2.queue[r2].callRejected(t2);
        return e2;
      }, o.resolve = function(e2) {
        if (e2 instanceof this)
          return e2;
        return l2.resolve(new this(u), e2);
      }, o.reject = function(e2) {
        var t2 = new this(u);
        return l2.reject(t2, e2);
      }, o.all = function(e2) {
        var r2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e2))
          return this.reject(new TypeError("must be an array"));
        var n2 = e2.length, i2 = false;
        if (!n2)
          return this.resolve([]);
        var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
        for (; ++t2 < n2; )
          h2(e2[t2], t2);
        return o2;
        function h2(e3, t3) {
          r2.resolve(e3).then(function(e4) {
            s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l2.resolve(o2, s2));
          }, function(e4) {
            i2 || (i2 = true, l2.reject(o2, e4));
          });
        }
      }, o.race = function(e2) {
        var t2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e2))
          return this.reject(new TypeError("must be an array"));
        var r2 = e2.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = -1, s2 = new this(u);
        for (; ++i2 < r2; )
          a2 = e2[i2], t2.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l2.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l2.reject(s2, e3));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(e, t, r) {
      var n = {};
      (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
      var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l2 = 0, f = -1, c = 0, d = 8;
      function p2(e2) {
        if (!(this instanceof p2))
          return new p2(e2);
        this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (r2 !== l2)
          throw new Error(i[r2]);
        if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          var n2;
          if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l2)
            throw new Error(i[r2]);
          this._dict_set = true;
        }
      }
      function n(e2, t2) {
        var r2 = new p2(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || i[r2.err];
        return r2.result;
      }
      p2.prototype.push = function(e2, t2) {
        var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
        do {
          if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l2)
            return this.onEnd(r2), !(this.ended = true);
          0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
        } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
        return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l2) : 2 !== n2 || (this.onEnd(l2), !(i2.avail_out = 0));
      }, p2.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, p2.prototype.onEnd = function(e2) {
        e2 === l2 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Deflate = p2, r.deflate = n, r.deflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, n(e2, t2);
      }, r.gzip = function(e2, t2) {
        return (t2 = t2 || {}).gzip = true, n(e2, t2);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
      var c = e("./zlib/inflate"), d = e("./utils/common"), p2 = e("./utils/strings"), m2 = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _2 = Object.prototype.toString;
      function a(e2) {
        if (!(this instanceof a))
          return new a(e2);
        this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
        var r2 = c.inflateInit2(this.strm, t2.windowBits);
        if (r2 !== m2.Z_OK)
          throw new Error(n[r2]);
        this.header = new s(), c.inflateGetHeader(this.strm, this.header);
      }
      function o(e2, t2) {
        var r2 = new a(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || n[r2.err];
        return r2.result;
      }
      a.prototype.push = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l2 = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? m2.Z_FINISH : m2.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p2.binstring2buf(e2) : "[object ArrayBuffer]" === _2.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
        do {
          if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT && l2 && (o2 = "string" == typeof l2 ? p2.string2buf(l2) : "[object ArrayBuffer]" === _2.call(l2) ? new Uint8Array(l2) : l2, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m2.Z_BUF_ERROR && true === f && (r2 = m2.Z_OK, f = false), r2 !== m2.Z_STREAM_END && r2 !== m2.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h.next_out && (0 !== h.avail_out && r2 !== m2.Z_STREAM_END && (0 !== h.avail_in || n2 !== m2.Z_FINISH && n2 !== m2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p2.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p2.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
        } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m2.Z_STREAM_END);
        return r2 === m2.Z_STREAM_END && (n2 = m2.Z_FINISH), n2 === m2.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m2.Z_OK) : n2 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h.avail_out = 0));
      }, a.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, a.prototype.onEnd = function(e2) {
        e2 === m2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, o(e2, t2);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      r.assign = function(e2) {
        for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
          var r2 = t2.shift();
          if (r2) {
            if ("object" != typeof r2)
              throw new TypeError(r2 + "must be non-object");
            for (var n2 in r2)
              r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
          }
        }
        return e2;
      }, r.shrinkBuf = function(e2, t2) {
        return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
      };
      var i = { arraySet: function(e2, t2, r2, n2, i2) {
        if (t2.subarray && e2.subarray)
          e2.set(t2.subarray(r2, r2 + n2), i2);
        else
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        var t2, r2, n2, i2, s2, a;
        for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
          n2 += e2[t2].length;
        for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
          s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
        return a;
      } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
        for (var s2 = 0; s2 < n2; s2++)
          e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        return [].concat.apply([], e2);
      } };
      r.setTyped = function(e2) {
        e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(n);
    }, {}], 42: [function(e, t, r) {
      var h = e("./common"), i = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e2) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        s = false;
      }
      for (var u = new h.Buf8(256), n = 0; n < 256; n++)
        u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
      function l2(e2, t2) {
        if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
          return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
        for (var r2 = "", n2 = 0; n2 < t2; n2++)
          r2 += String.fromCharCode(e2[n2]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(e2) {
        var t2, r2, n2, i2, s2, a = e2.length, o = 0;
        for (i2 = 0; i2 < a; i2++)
          55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
          55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
        return t2;
      }, r.buf2binstring = function(e2) {
        return l2(e2, e2.length);
      }, r.binstring2buf = function(e2) {
        for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
          t2[r2] = e2.charCodeAt(r2);
        return t2;
      }, r.buf2string = function(e2, t2) {
        var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
        for (r2 = n2 = 0; r2 < a; )
          if ((i2 = e2[r2++]) < 128)
            o[n2++] = i2;
          else if (4 < (s2 = u[i2]))
            o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
              i2 = i2 << 6 | 63 & e2[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
        return l2(o, n2);
      }, r.utf8border = function(e2, t2) {
        var r2;
        for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
          r2--;
        return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
      };
    }, { "./common": 41 }], 43: [function(e, t, r) {
      t.exports = function(e2, t2, r2, n) {
        for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
          for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
            ;
          i %= 65521, s %= 65521;
        }
        return i | s << 16 | 0;
      };
    }, {}], 44: [function(e, t, r) {
      t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, t, r) {
      var o = function() {
        for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
          e2 = r2;
          for (var n = 0; n < 8; n++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2, r2, n) {
        var i = o, s = n + r2;
        e2 ^= -1;
        for (var a = n; a < s; a++)
          e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
        return -1 ^ e2;
      };
    }, {}], 46: [function(e, t, r) {
      var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p2 = e("./crc32"), n = e("./messages"), l2 = 0, f = 4, m2 = 0, _2 = -2, g = -1, b = 4, i = 2, v2 = 8, y = 9, s = 286, a = 30, o = 19, w2 = 2 * s + 1, k2 = 15, x2 = 3, S2 = 258, z2 = S2 + x2 + 1, C = 42, E2 = 113, A2 = 1, I2 = 2, O2 = 3, B2 = 4;
      function R2(e2, t2) {
        return e2.msg = n[t2], t2;
      }
      function T(e2) {
        return (e2 << 1) - (4 < e2 ? 9 : 0);
      }
      function D2(e2) {
        for (var t2 = e2.length; 0 <= --t2; )
          e2[t2] = 0;
      }
      function F(e2) {
        var t2 = e2.state, r2 = t2.pending;
        r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
      }
      function N2(e2, t2) {
        u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
      }
      function U2(e2, t2) {
        e2.pending_buf[e2.pending++] = t2;
      }
      function P2(e2, t2) {
        e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
      }
      function L2(e2, t2) {
        var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z2 ? e2.strstart - (e2.w_size - z2) : 0, u2 = e2.window, l3 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S2, d2 = u2[s2 + a2 - 1], p3 = u2[s2 + a2];
        e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
        do {
          if (u2[(r2 = t2) + a2] === p3 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {
            } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
            if (n2 = S2 - (c2 - s2), s2 = c2 - S2, a2 < n2) {
              if (e2.match_start = t2, o2 <= (a2 = n2))
                break;
              d2 = u2[s2 + a2 - 1], p3 = u2[s2 + a2];
            }
          }
        } while ((t2 = f2[t2 & l3]) > h2 && 0 != --i2);
        return a2 <= e2.lookahead ? a2 : e2.lookahead;
      }
      function j2(e2) {
        var t2, r2, n2, i2, s2, a2, o2, h2, u2, l3, f2 = e2.w_size;
        do {
          if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z2)) {
            for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            i2 += f2;
          }
          if (0 === e2.strm.avail_in)
            break;
          if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l3 = void 0, l3 = a2.avail_in, u2 < l3 && (l3 = u2), r2 = 0 === l3 ? 0 : (a2.avail_in -= l3, c.arraySet(o2, a2.input, a2.next_in, l3, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l3, h2) : 2 === a2.state.wrap && (a2.adler = p2(a2.adler, o2, l3, h2)), a2.next_in += l3, a2.total_in += l3, l3), e2.lookahead += r2, e2.lookahead + e2.insert >= x2)
            for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x2 - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x2)); )
              ;
        } while (e2.lookahead < z2 && 0 !== e2.strm.avail_in);
      }
      function Z2(e2, t2) {
        for (var r2, n2; ; ) {
          if (e2.lookahead < z2) {
            if (j2(e2), e2.lookahead < z2 && t2 === l2)
              return A2;
            if (0 === e2.lookahead)
              break;
          }
          if (r2 = 0, e2.lookahead >= x2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x2 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L2(e2, r2)), e2.match_length >= x2)
            if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x2), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x2) {
              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x2 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                ;
              e2.strstart++;
            } else
              e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
          else
            n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n2 && (N2(e2, false), 0 === e2.strm.avail_out))
            return A2;
        }
        return e2.insert = e2.strstart < x2 - 1 ? e2.strstart : x2 - 1, t2 === f ? (N2(e2, true), 0 === e2.strm.avail_out ? O2 : B2) : e2.last_lit && (N2(e2, false), 0 === e2.strm.avail_out) ? A2 : I2;
      }
      function W(e2, t2) {
        for (var r2, n2, i2; ; ) {
          if (e2.lookahead < z2) {
            if (j2(e2), e2.lookahead < z2 && t2 === l2)
              return A2;
            if (0 === e2.lookahead)
              break;
          }
          if (r2 = 0, e2.lookahead >= x2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x2 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x2 - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z2 && (e2.match_length = L2(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x2 && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x2 - 1)), e2.prev_length >= x2 && e2.match_length <= e2.prev_length) {
            for (i2 = e2.strstart + e2.lookahead - x2, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x2), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x2 - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
              ;
            if (e2.match_available = 0, e2.match_length = x2 - 1, e2.strstart++, n2 && (N2(e2, false), 0 === e2.strm.avail_out))
              return A2;
          } else if (e2.match_available) {
            if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N2(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
              return A2;
          } else
            e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x2 - 1 ? e2.strstart : x2 - 1, t2 === f ? (N2(e2, true), 0 === e2.strm.avail_out ? O2 : B2) : e2.last_lit && (N2(e2, false), 0 === e2.strm.avail_out) ? A2 : I2;
      }
      function M2(e2, t2, r2, n2, i2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
      }
      function H2() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w2), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k2 + 1), this.heap = new c.Buf16(2 * s + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G2(e2) {
        var t2;
        return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E2, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l2, u._tr_init(t2), m2) : R2(e2, _2);
      }
      function K2(e2) {
        var t2 = G2(e2);
        return t2 === m2 && function(e3) {
          e3.window_size = 2 * e3.w_size, D2(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x2 - 1, e3.match_available = 0, e3.ins_h = 0;
        }(e2.state), t2;
      }
      function Y2(e2, t2, r2, n2, i2, s2) {
        if (!e2)
          return _2;
        var a2 = 1;
        if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v2 || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
          return R2(e2, _2);
        8 === n2 && (n2 = 9);
        var o2 = new H2();
        return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x2 - 1) / x2), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K2(e2);
      }
      h = [new M2(0, 0, 0, 0, function(e2, t2) {
        var r2 = 65535;
        for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
          if (e2.lookahead <= 1) {
            if (j2(e2), 0 === e2.lookahead && t2 === l2)
              return A2;
            if (0 === e2.lookahead)
              break;
          }
          e2.strstart += e2.lookahead, e2.lookahead = 0;
          var n2 = e2.block_start + r2;
          if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N2(e2, false), 0 === e2.strm.avail_out))
            return A2;
          if (e2.strstart - e2.block_start >= e2.w_size - z2 && (N2(e2, false), 0 === e2.strm.avail_out))
            return A2;
        }
        return e2.insert = 0, t2 === f ? (N2(e2, true), 0 === e2.strm.avail_out ? O2 : B2) : (e2.strstart > e2.block_start && (N2(e2, false), e2.strm.avail_out), A2);
      }), new M2(4, 4, 8, 4, Z2), new M2(4, 5, 16, 8, Z2), new M2(4, 6, 32, 32, Z2), new M2(4, 4, 16, 16, W), new M2(8, 16, 32, 32, W), new M2(8, 16, 128, 128, W), new M2(8, 32, 128, 256, W), new M2(32, 128, 258, 1024, W), new M2(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
        return Y2(e2, t2, v2, 15, 8, 0);
      }, r.deflateInit2 = Y2, r.deflateReset = K2, r.deflateResetKeep = G2, r.deflateSetHeader = function(e2, t2) {
        return e2 && e2.state ? 2 !== e2.state.wrap ? _2 : (e2.state.gzhead = t2, m2) : _2;
      }, r.deflate = function(e2, t2) {
        var r2, n2, i2, s2;
        if (!e2 || !e2.state || 5 < t2 || t2 < 0)
          return e2 ? R2(e2, _2) : _2;
        if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
          return R2(e2, 0 === e2.avail_out ? -5 : _2);
        if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
          if (2 === n2.wrap)
            e2.adler = 0, U2(n2, 31), U2(n2, 139), U2(n2, 8), n2.gzhead ? (U2(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U2(n2, 255 & n2.gzhead.time), U2(n2, n2.gzhead.time >> 8 & 255), U2(n2, n2.gzhead.time >> 16 & 255), U2(n2, n2.gzhead.time >> 24 & 255), U2(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U2(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U2(n2, 255 & n2.gzhead.extra.length), U2(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p2(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U2(n2, 3), n2.status = E2);
          else {
            var a2 = v2 + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E2, P2(n2, a2), 0 !== n2.strstart && (P2(n2, e2.adler >>> 16), P2(n2, 65535 & e2.adler)), e2.adler = 1;
          }
        if (69 === n2.status)
          if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p2(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
              U2(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p2(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else
            n2.status = 73;
        if (73 === n2.status)
          if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p2(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U2(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p2(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else
            n2.status = 91;
        if (91 === n2.status)
          if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p2(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U2(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p2(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else
            n2.status = 103;
        if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U2(n2, 255 & e2.adler), U2(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E2)) : n2.status = E2), 0 !== n2.pending) {
          if (F(e2), 0 === e2.avail_out)
            return n2.last_flush = -1, m2;
        } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
          return R2(e2, -5);
        if (666 === n2.status && 0 !== e2.avail_in)
          return R2(e2, -5);
        if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l2 && 666 !== n2.status) {
          var o2 = 2 === n2.strategy ? function(e3, t3) {
            for (var r3; ; ) {
              if (0 === e3.lookahead && (j2(e3), 0 === e3.lookahead)) {
                if (t3 === l2)
                  return A2;
                break;
              }
              if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N2(e3, false), 0 === e3.strm.avail_out))
                return A2;
            }
            return e3.insert = 0, t3 === f ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
          }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
            for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
              if (e3.lookahead <= S2) {
                if (j2(e3), e3.lookahead <= S2 && t3 === l2)
                  return A2;
                if (0 === e3.lookahead)
                  break;
              }
              if (e3.match_length = 0, e3.lookahead >= x2 && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                s3 = e3.strstart + S2;
                do {
                } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                e3.match_length = S2 - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= x2 ? (r3 = u._tr_tally(e3, 1, e3.match_length - x2), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N2(e3, false), 0 === e3.strm.avail_out))
                return A2;
            }
            return e3.insert = 0, t3 === f ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A2 : I2;
          }(n2, t2) : h[n2.level].func(n2, t2);
          if (o2 !== O2 && o2 !== B2 || (n2.status = 666), o2 === A2 || o2 === O2)
            return 0 === e2.avail_out && (n2.last_flush = -1), m2;
          if (o2 === I2 && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D2(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
            return n2.last_flush = -1, m2;
        }
        return t2 !== f ? m2 : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U2(n2, 255 & e2.adler), U2(n2, e2.adler >> 8 & 255), U2(n2, e2.adler >> 16 & 255), U2(n2, e2.adler >> 24 & 255), U2(n2, 255 & e2.total_in), U2(n2, e2.total_in >> 8 & 255), U2(n2, e2.total_in >> 16 & 255), U2(n2, e2.total_in >> 24 & 255)) : (P2(n2, e2.adler >>> 16), P2(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m2 : 1);
      }, r.deflateEnd = function(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E2 && 666 !== t2 ? R2(e2, _2) : (e2.state = null, t2 === E2 ? R2(e2, -3) : m2) : _2;
      }, r.deflateSetDictionary = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l3 = t2.length;
        if (!e2 || !e2.state)
          return _2;
        if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
          return _2;
        for (1 === s2 && (e2.adler = d(e2.adler, t2, l3, 0)), r2.wrap = 0, l3 >= r2.w_size && (0 === s2 && (D2(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l3 - r2.w_size, r2.w_size, 0), t2 = u2, l3 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l3, e2.next_in = 0, e2.input = t2, j2(r2); r2.lookahead >= x2; ) {
          for (n2 = r2.strstart, i2 = r2.lookahead - (x2 - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x2 - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
            ;
          r2.strstart = n2, r2.lookahead = x2 - 1, j2(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x2 - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m2;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
      t.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e, t, r) {
      t.exports = function(e2, t2) {
        var r2, n, i, s, a, o, h, u, l2, f, c, d, p2, m2, _2, g, b, v2, y, w2, k2, x2, S2, z2, C;
        r2 = e2.state, n = e2.next_in, z2 = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l2 = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p2 = r2.bits, m2 = r2.lencode, _2 = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        e:
          do {
            p2 < 15 && (d += z2[n++] << p2, p2 += 8, d += z2[n++] << p2, p2 += 8), v2 = m2[d & g];
            t:
              for (; ; ) {
                if (d >>>= y = v2 >>> 24, p2 -= y, 0 === (y = v2 >>> 16 & 255))
                  C[s++] = 65535 & v2;
                else {
                  if (!(16 & y)) {
                    if (0 == (64 & y)) {
                      v2 = m2[(65535 & v2) + (d & (1 << y) - 1)];
                      continue t;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break e;
                    }
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break e;
                  }
                  w2 = 65535 & v2, (y &= 15) && (p2 < y && (d += z2[n++] << p2, p2 += 8), w2 += d & (1 << y) - 1, d >>>= y, p2 -= y), p2 < 15 && (d += z2[n++] << p2, p2 += 8, d += z2[n++] << p2, p2 += 8), v2 = _2[d & b];
                  r:
                    for (; ; ) {
                      if (d >>>= y = v2 >>> 24, p2 -= y, !(16 & (y = v2 >>> 16 & 255))) {
                        if (0 == (64 & y)) {
                          v2 = _2[(65535 & v2) + (d & (1 << y) - 1)];
                          continue r;
                        }
                        e2.msg = "invalid distance code", r2.mode = 30;
                        break e;
                      }
                      if (k2 = 65535 & v2, p2 < (y &= 15) && (d += z2[n++] << p2, (p2 += 8) < y && (d += z2[n++] << p2, p2 += 8)), h < (k2 += d & (1 << y) - 1)) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (d >>>= y, p2 -= y, (y = s - a) < k2) {
                        if (l2 < (y = k2 - y) && r2.sane) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (S2 = c, (x2 = 0) === f) {
                          if (x2 += u - y, y < w2) {
                            for (w2 -= y; C[s++] = c[x2++], --y; )
                              ;
                            x2 = s - k2, S2 = C;
                          }
                        } else if (f < y) {
                          if (x2 += u + f - y, (y -= f) < w2) {
                            for (w2 -= y; C[s++] = c[x2++], --y; )
                              ;
                            if (x2 = 0, f < w2) {
                              for (w2 -= y = f; C[s++] = c[x2++], --y; )
                                ;
                              x2 = s - k2, S2 = C;
                            }
                          }
                        } else if (x2 += f - y, y < w2) {
                          for (w2 -= y; C[s++] = c[x2++], --y; )
                            ;
                          x2 = s - k2, S2 = C;
                        }
                        for (; 2 < w2; )
                          C[s++] = S2[x2++], C[s++] = S2[x2++], C[s++] = S2[x2++], w2 -= 3;
                        w2 && (C[s++] = S2[x2++], 1 < w2 && (C[s++] = S2[x2++]));
                      } else {
                        for (x2 = s - k2; C[s++] = C[x2++], C[s++] = C[x2++], C[s++] = C[x2++], 2 < (w2 -= 3); )
                          ;
                        w2 && (C[s++] = C[x2++], 1 < w2 && (C[s++] = C[x2++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n < i && s < o);
        n -= w2 = p2 >> 3, d &= (1 << (p2 -= w2 << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p2;
      };
    }, {}], 49: [function(e, t, r) {
      var I2 = e("../utils/common"), O2 = e("./adler32"), B2 = e("./crc32"), R2 = e("./inffast"), T = e("./inftrees"), D2 = 1, F = 2, N2 = 0, U2 = -2, P2 = 1, n = 852, i = 592;
      function L2(e2) {
        return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I2.Buf16(320), this.work = new I2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P2, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I2.Buf32(n), t2.distcode = t2.distdyn = new I2.Buf32(i), t2.sane = 1, t2.back = -1, N2) : U2;
      }
      function o(e2) {
        var t2;
        return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U2;
      }
      function h(e2, t2) {
        var r2, n2;
        return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U2 : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U2;
      }
      function u(e2, t2) {
        var r2, n2;
        return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N2 && (e2.state = null), r2) : U2;
      }
      var l2, f, c = true;
      function j2(e2) {
        if (c) {
          var t2;
          for (l2 = new I2.Buf32(512), f = new I2.Buf32(32), t2 = 0; t2 < 144; )
            e2.lens[t2++] = 8;
          for (; t2 < 256; )
            e2.lens[t2++] = 9;
          for (; t2 < 280; )
            e2.lens[t2++] = 7;
          for (; t2 < 288; )
            e2.lens[t2++] = 8;
          for (T(D2, e2.lens, 0, 288, l2, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
            e2.lens[t2++] = 5;
          T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
        }
        e2.lencode = l2, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
      }
      function Z2(e2, t2, r2, n2) {
        var i2, s2 = e2.state;
        return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I2.Buf8(s2.wsize)), n2 >= s2.wsize ? (I2.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I2.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I2.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
        return u(e2, 15);
      }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l3, f2, c2, d, p2, m2, _2, g, b, v2, y, w2, k2, x2, S2, z2, C = 0, E2 = new I2.Buf8(4), A2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
          return U2;
        12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l3 = r2.bits, f2 = o2, c2 = h2, x2 = N2;
        e:
          for (; ; )
            switch (r2.mode) {
              case P2:
                if (0 === r2.wrap) {
                  r2.mode = 13;
                  break;
                }
                for (; l3 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                if (2 & r2.wrap && 35615 === u2) {
                  E2[r2.check = 0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0), l3 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  e2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if (8 != (15 & u2)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l3 -= 4, k2 = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                  r2.wbits = k2;
                else if (k2 > r2.wbits) {
                  e2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k2, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l3 = u2 = 0;
                break;
              case 2:
                for (; l3 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                if (r2.flags = u2, 8 != (255 & r2.flags)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  e2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0)), l3 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l3 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, E2[2] = u2 >>> 16 & 255, E2[3] = u2 >>> 24 & 255, r2.check = B2(r2.check, E2, 4, 0)), l3 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l3 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0)), l3 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l3 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r2.check = B2(r2.check, E2, 2, 0)), l3 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k2 = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I2.arraySet(r2.head.extra, n2, s2, d, k2)), 512 & r2.flags && (r2.check = B2(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                  break e;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k2 = n2[s2 + d++], r2.head && k2 && r2.length < 65536 && (r2.head.name += String.fromCharCode(k2)), k2 && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B2(r2.check, n2, d, s2)), o2 -= d, s2 += d, k2)
                    break e;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k2 = n2[s2 + d++], r2.head && k2 && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k2)), k2 && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B2(r2.check, n2, d, s2)), o2 -= d, s2 += d, k2)
                    break e;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l3 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    e2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l3 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l3 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                e2.adler = r2.check = L2(u2), l3 = u2 = 0, r2.mode = 11;
              case 11:
                if (0 === r2.havedict)
                  return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l3, 2;
                e2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (5 === t2 || 6 === t2)
                  break e;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l3, l3 -= 7 & l3, r2.mode = 27;
                  break;
                }
                for (; l3 < 3; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                switch (r2.last = 1 & u2, l3 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j2(r2), r2.mode = 20, 6 !== t2)
                      break;
                    u2 >>>= 2, l3 -= 2;
                    break e;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    e2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l3 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l3, l3 -= 7 & l3; l3 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  e2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l3 = u2 = 0, r2.mode = 15, 6 === t2)
                  break e;
              case 15:
                r2.mode = 16;
              case 16:
                if (d = r2.length) {
                  if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                    break e;
                  I2.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l3 < 14; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l3 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l3 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l3 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  e2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l3 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  r2.lens[A2[r2.have++]] = 7 & u2, u2 >>>= 3, l3 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[A2[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S2 = { bits: r2.lenbits }, x2 = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, x2) {
                  e2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _2, l3 -= _2, r2.lens[r2.have++] = b;
                  else {
                    if (16 === b) {
                      for (z2 = _2 + 2; l3 < z2; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l3, l3 += 8;
                      }
                      if (u2 >>>= _2, l3 -= _2, 0 === r2.have) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k2 = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l3 -= 2;
                    } else if (17 === b) {
                      for (z2 = _2 + 3; l3 < z2; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l3, l3 += 8;
                      }
                      l3 -= _2, k2 = 0, d = 3 + (7 & (u2 >>>= _2)), u2 >>>= 3, l3 -= 3;
                    } else {
                      for (z2 = _2 + 7; l3 < z2; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l3, l3 += 8;
                      }
                      l3 -= _2, k2 = 0, d = 11 + (127 & (u2 >>>= _2)), u2 >>>= 7, l3 -= 7;
                    }
                    if (r2.have + d > r2.nlen + r2.ndist) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; d--; )
                      r2.lens[r2.have++] = k2;
                  }
                }
                if (30 === r2.mode)
                  break;
                if (0 === r2.lens[256]) {
                  e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S2 = { bits: r2.lenbits }, x2 = T(D2, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S2), r2.lenbits = S2.bits, x2) {
                  e2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S2 = { bits: r2.distbits }, x2 = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S2), r2.distbits = S2.bits, x2) {
                  e2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, 6 === t2)
                  break e;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l3, R2(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l3 = r2.bits, 12 === r2.mode && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v2 = _2, y = g, w2 = b; g = (C = r2.lencode[w2 + ((u2 & (1 << v2 + y) - 1) >> v2)]) >>> 16 & 255, b = 65535 & C, !(v2 + (_2 = C >>> 24) <= l3); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  u2 >>>= v2, l3 -= v2, r2.back += v2;
                }
                if (u2 >>>= _2, l3 -= _2, r2.back += _2, r2.length = b, 0 === g) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z2 = r2.extra; l3 < z2; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l3 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_2 = C >>> 24) <= l3); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l3, l3 += 8;
                }
                if (0 == (240 & g)) {
                  for (v2 = _2, y = g, w2 = b; g = (C = r2.distcode[w2 + ((u2 & (1 << v2 + y) - 1) >> v2)]) >>> 16 & 255, b = 65535 & C, !(v2 + (_2 = C >>> 24) <= l3); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  u2 >>>= v2, l3 -= v2, r2.back += v2;
                }
                if (u2 >>>= _2, l3 -= _2, r2.back += _2, 64 & g) {
                  e2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z2 = r2.extra; l3 < z2; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l3 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (0 === h2)
                  break e;
                if (d = c2 - h2, r2.offset > d) {
                  if ((d = r2.offset - d) > r2.whave && r2.sane) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p2 = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m2 = r2.window;
                } else
                  m2 = i2, p2 = a2 - r2.offset, d = r2.length;
                for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m2[p2++], --d; )
                  ;
                0 === r2.length && (r2.mode = 21);
                break;
              case 26:
                if (0 === h2)
                  break e;
                i2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l3 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 |= n2[s2++] << l3, l3 += 8;
                  }
                  if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B2(r2.check, i2, c2, a2 - c2) : O2(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L2(u2)) !== r2.check) {
                    e2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l3 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l3 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l3, l3 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    e2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l3 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x2 = 1;
                break e;
              case 30:
                x2 = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U2;
            }
        return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l3, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z2(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B2(r2.check, i2, c2, e2.next_out - c2) : O2(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x2 === N2 && (x2 = -5), x2);
      }, r.inflateEnd = function(e2) {
        if (!e2 || !e2.state)
          return U2;
        var t2 = e2.state;
        return t2.window && (t2.window = null), e2.state = null, N2;
      }, r.inflateGetHeader = function(e2, t2) {
        var r2;
        return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U2 : ((r2.head = t2).done = false, N2) : U2;
      }, r.inflateSetDictionary = function(e2, t2) {
        var r2, n2 = t2.length;
        return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U2 : 11 === r2.mode && O2(1, t2, n2, 0) !== r2.check ? -3 : Z2(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N2) : U2;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
      var D2 = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t.exports = function(e2, t2, r2, n, i, s, a, o) {
        var h, u, l2, f, c, d, p2, m2, _2, g = o.bits, b = 0, v2 = 0, y = 0, w2 = 0, k2 = 0, x2 = 0, S2 = 0, z2 = 0, C = 0, E2 = 0, A2 = null, I2 = 0, O2 = new D2.Buf16(16), B2 = new D2.Buf16(16), R2 = null, T = 0;
        for (b = 0; b <= 15; b++)
          O2[b] = 0;
        for (v2 = 0; v2 < n; v2++)
          O2[t2[r2 + v2]]++;
        for (k2 = g, w2 = 15; 1 <= w2 && 0 === O2[w2]; w2--)
          ;
        if (w2 < k2 && (k2 = w2), 0 === w2)
          return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
        for (y = 1; y < w2 && 0 === O2[y]; y++)
          ;
        for (k2 < y && (k2 = y), b = z2 = 1; b <= 15; b++)
          if (z2 <<= 1, (z2 -= O2[b]) < 0)
            return -1;
        if (0 < z2 && (0 === e2 || 1 !== w2))
          return -1;
        for (B2[1] = 0, b = 1; b < 15; b++)
          B2[b + 1] = B2[b] + O2[b];
        for (v2 = 0; v2 < n; v2++)
          0 !== t2[r2 + v2] && (a[B2[t2[r2 + v2]]++] = v2);
        if (d = 0 === e2 ? (A2 = R2 = a, 19) : 1 === e2 ? (A2 = F, I2 -= 257, R2 = N2, T -= 257, 256) : (A2 = U2, R2 = P2, -1), b = y, c = s, S2 = v2 = E2 = 0, l2 = -1, f = (C = 1 << (x2 = k2)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
          return 1;
        for (; ; ) {
          for (p2 = b - S2, _2 = a[v2] < d ? (m2 = 0, a[v2]) : a[v2] > d ? (m2 = R2[T + a[v2]], A2[I2 + a[v2]]) : (m2 = 96, 0), h = 1 << b - S2, y = u = 1 << x2; i[c + (E2 >> S2) + (u -= h)] = p2 << 24 | m2 << 16 | _2 | 0, 0 !== u; )
            ;
          for (h = 1 << b - 1; E2 & h; )
            h >>= 1;
          if (0 !== h ? (E2 &= h - 1, E2 += h) : E2 = 0, v2++, 0 == --O2[b]) {
            if (b === w2)
              break;
            b = t2[r2 + a[v2]];
          }
          if (k2 < b && (E2 & f) !== l2) {
            for (0 === S2 && (S2 = k2), c += y, z2 = 1 << (x2 = b - S2); x2 + S2 < w2 && !((z2 -= O2[x2 + S2]) <= 0); )
              x2++, z2 <<= 1;
            if (C += 1 << x2, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
              return 1;
            i[l2 = E2 & f] = k2 << 24 | x2 << 16 | c - s | 0;
          }
        }
        return 0 !== E2 && (i[c + E2] = b - S2 << 24 | 64 << 16 | 0), o.bits = k2, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, t, r) {
      t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, t, r) {
      var i = e("../utils/common"), o = 0, h = 1;
      function n(e2) {
        for (var t2 = e2.length; 0 <= --t2; )
          e2[t2] = 0;
      }
      var s = 0, a = 29, u = 256, l2 = u + 1 + a, f = 30, c = 19, _2 = 2 * l2 + 1, g = 15, d = 16, p2 = 7, m2 = 256, b = 16, v2 = 17, y = 18, w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k2 = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l2 + 2));
      n(z2);
      var C = new Array(2 * f);
      n(C);
      var E2 = new Array(512);
      n(E2);
      var A2 = new Array(256);
      n(A2);
      var I2 = new Array(a);
      n(I2);
      var O2, B2, R2, T = new Array(f);
      function D2(e2, t2, r2, n2, i2) {
        this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
      }
      function F(e2, t2) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
      }
      function N2(e2) {
        return e2 < 256 ? E2[e2] : E2[256 + (e2 >>> 7)];
      }
      function U2(e2, t2) {
        e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
      }
      function P2(e2, t2, r2) {
        e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U2(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
      }
      function L2(e2, t2, r2) {
        P2(e2, r2[2 * t2], r2[2 * t2 + 1]);
      }
      function j2(e2, t2) {
        for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
          ;
        return r2 >>> 1;
      }
      function Z2(e2, t2, r2) {
        var n2, i2, s2 = new Array(g + 1), a2 = 0;
        for (n2 = 1; n2 <= g; n2++)
          s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
        for (i2 = 0; i2 <= t2; i2++) {
          var o2 = e2[2 * i2 + 1];
          0 !== o2 && (e2[2 * i2] = j2(s2[o2]++, o2));
        }
      }
      function W(e2) {
        var t2;
        for (t2 = 0; t2 < l2; t2++)
          e2.dyn_ltree[2 * t2] = 0;
        for (t2 = 0; t2 < f; t2++)
          e2.dyn_dtree[2 * t2] = 0;
        for (t2 = 0; t2 < c; t2++)
          e2.bl_tree[2 * t2] = 0;
        e2.dyn_ltree[2 * m2] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
      }
      function M2(e2) {
        8 < e2.bi_valid ? U2(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }
      function H2(e2, t2, r2, n2) {
        var i2 = 2 * t2, s2 = 2 * r2;
        return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
      }
      function G2(e2, t2, r2) {
        for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H2(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H2(t2, n2, e2.heap[i2], e2.depth)); )
          e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
        e2.heap[r2] = n2;
      }
      function K2(e2, t2, r2) {
        var n2, i2, s2, a2, o2 = 0;
        if (0 !== e2.last_lit)
          for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L2(e2, i2, t2) : (L2(e2, (s2 = A2[i2]) + u + 1, t2), 0 !== (a2 = w2[s2]) && P2(e2, i2 -= I2[s2], a2), L2(e2, s2 = N2(--n2), r2), 0 !== (a2 = k2[s2]) && P2(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
            ;
        L2(e2, m2, t2);
      }
      function Y2(e2, t2) {
        var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
        for (e2.heap_len = 0, e2.heap_max = _2, r2 = 0; r2 < h2; r2++)
          0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (; e2.heap_len < 2; )
          s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
        for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
          G2(e2, s2, r2);
        for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G2(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G2(e2, s2, 1), 2 <= e2.heap_len; )
          ;
        e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l3 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p3 = t3.stat_desc.max_length, m3 = 0;
          for (s3 = 0; s3 <= g; s3++)
            e3.bl_count[s3] = 0;
          for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _2; r3++)
            p3 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p3, m3++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l3[2 * n3 + 1] + a3)));
          if (0 !== m3) {
            do {
              for (s3 = p3 - 1; 0 === e3.bl_count[s3]; )
                s3--;
              e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p3]--, m3 -= 2;
            } while (0 < m3);
            for (s3 = p3; 0 !== s3; s3--)
              for (n3 = e3.bl_count[s3]; 0 !== n3; )
                u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
          }
        }(e2, t2), Z2(s2, u2, e2.bl_count);
      }
      function X2(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
          i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v2]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
      }
      function V2(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
          if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
            if (o2 < u2)
              for (; L2(e2, i2, e2.bl_tree), 0 != --o2; )
                ;
            else
              0 !== i2 ? (i2 !== s2 && (L2(e2, i2, e2.bl_tree), o2--), L2(e2, b, e2.bl_tree), P2(e2, o2 - 3, 2)) : o2 <= 10 ? (L2(e2, v2, e2.bl_tree), P2(e2, o2 - 3, 3)) : (L2(e2, y, e2.bl_tree), P2(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
      }
      n(T);
      var q2 = false;
      function J2(e2, t2, r2, n2) {
        P2(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          M2(e3), n3 && (U2(e3, r3), U2(e3, ~r3)), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
        }(e2, t2, r2, true);
      }
      r._tr_init = function(e2) {
        q2 || (function() {
          var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
          for (n2 = r2 = 0; n2 < a - 1; n2++)
            for (I2[n2] = r2, e3 = 0; e3 < 1 << w2[n2]; e3++)
              A2[r2++] = n2;
          for (A2[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
            for (T[n2] = i2, e3 = 0; e3 < 1 << k2[n2]; e3++)
              E2[i2++] = n2;
          for (i2 >>= 7; n2 < f; n2++)
            for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k2[n2] - 7; e3++)
              E2[256 + i2++] = n2;
          for (t2 = 0; t2 <= g; t2++)
            s2[t2] = 0;
          for (e3 = 0; e3 <= 143; )
            z2[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (; e3 <= 255; )
            z2[2 * e3 + 1] = 9, e3++, s2[9]++;
          for (; e3 <= 279; )
            z2[2 * e3 + 1] = 7, e3++, s2[7]++;
          for (; e3 <= 287; )
            z2[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (Z2(z2, l2 + 1, s2), e3 = 0; e3 < f; e3++)
            C[2 * e3 + 1] = 5, C[2 * e3] = j2(e3, 5);
          O2 = new D2(z2, w2, u + 1, l2, g), B2 = new D2(C, k2, 0, f, g), R2 = new D2(new Array(0), x2, 0, c, p2);
        }(), q2 = true), e2.l_desc = new F(e2.dyn_ltree, O2), e2.d_desc = new F(e2.dyn_dtree, B2), e2.bl_desc = new F(e2.bl_tree, R2), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
      }, r._tr_stored_block = J2, r._tr_flush_block = function(e2, t2, r2, n2) {
        var i2, s2, a2 = 0;
        0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
          var t3, r3 = 4093624447;
          for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
            if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
              return o;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
            return h;
          for (t3 = 32; t3 < u; t3++)
            if (0 !== e3.dyn_ltree[2 * t3])
              return h;
          return o;
        }(e2)), Y2(e2, e2.l_desc), Y2(e2, e2.d_desc), a2 = function(e3) {
          var t3;
          for (X2(e3, e3.dyn_ltree, e3.l_desc.max_code), X2(e3, e3.dyn_dtree, e3.d_desc.max_code), Y2(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S2[t3] + 1]; t3--)
            ;
          return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J2(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P2(e2, 2 + (n2 ? 1 : 0), 3), K2(e2, z2, C)) : (P2(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          var i3;
          for (P2(e3, t3 - 257, 5), P2(e3, r3 - 1, 5), P2(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
            P2(e3, e3.bl_tree[2 * S2[i3] + 1], 3);
          V2(e3, e3.dyn_ltree, t3 - 1), V2(e3, e3.dyn_dtree, r3 - 1);
        }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K2(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M2(e2);
      }, r._tr_tally = function(e2, t2, r2) {
        return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A2[r2] + u + 1)]++, e2.dyn_dtree[2 * N2(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
      }, r._tr_align = function(e2) {
        P2(e2, 2, 3), L2(e2, m2, z2), function(e3) {
          16 === e3.bi_valid ? (U2(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        }(e2);
      };
    }, { "../utils/common": 41 }], 53: [function(e, t, r) {
      t.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, t, r) {
      (function(e2) {
        !function(r2, n) {
          if (!r2.setImmediate) {
            var i, s, t2, a, o = 1, h = {}, u = false, l2 = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
            e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
              process.nextTick(function() {
                c(e4);
              });
            } : function() {
              if (r2.postMessage && !r2.importScripts) {
                var e4 = true, t3 = r2.onmessage;
                return r2.onmessage = function() {
                  e4 = false;
                }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
              }
            }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
              r2.postMessage(a + e4, "*");
            }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
              c(e4.data);
            }, function(e4) {
              t2.port2.postMessage(e4);
            }) : l2 && "onreadystatechange" in l2.createElement("script") ? (s = l2.documentElement, function(e4) {
              var t3 = l2.createElement("script");
              t3.onreadystatechange = function() {
                c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
              }, s.appendChild(t3);
            }) : function(e4) {
              setTimeout(c, 0, e4);
            }, e3.setImmediate = function(e4) {
              "function" != typeof e4 && (e4 = new Function("" + e4));
              for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                t3[r3] = arguments[r3 + 1];
              var n2 = { callback: e4, args: t3 };
              return h[o] = n2, i(o), o++;
            }, e3.clearImmediate = f;
          }
          function f(e4) {
            delete h[e4];
          }
          function c(e4) {
            if (u)
              setTimeout(c, 0, e4);
            else {
              var t3 = h[e4];
              if (t3) {
                u = true;
                try {
                  !function(e5) {
                    var t4 = e5.callback, r3 = e5.args;
                    switch (r3.length) {
                      case 0:
                        t4();
                        break;
                      case 1:
                        t4(r3[0]);
                        break;
                      case 2:
                        t4(r3[0], r3[1]);
                        break;
                      case 3:
                        t4(r3[0], r3[1], r3[2]);
                        break;
                      default:
                        t4.apply(n, r3);
                    }
                  }(t3);
                } finally {
                  f(e4), u = false;
                }
              }
            }
          }
          function d(e4) {
            e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
          }
        }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var jszip_minExports = jszip_min.exports;
const Fe = /* @__PURE__ */ getDefaultExportFromCjs(jszip_minExports);
var events = { exports: {} };
var R$1 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$1 && typeof R$1.ownKeys === "function") {
  ReflectOwnKeys = R$1.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once2;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++)
    args.push(arguments[i]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er2;
    if (args.length > 0)
      er2 = args[0];
    if (er2 instanceof Error) {
      throw er2;
    }
    var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
    err.context = er2;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners2[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m2;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m2 = _getMaxListeners(target);
    if (m2 > 0 && existing.length > m2 && !existing.warned) {
      existing.warned = true;
      var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w2.name = "MaxListenersExceededWarning";
      w2.emitter = target;
      w2.type = type;
      w2.count = existing.length;
      ProcessEmitWarning(w2);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i = listeners2.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners2[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index2) {
  for (; index2 + 1 < list.length; index2++)
    list[index2] = list[index2 + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once2(emitter, name) {
  return new Promise(function(resolve2, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve2([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var eventsExports = events.exports;
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt2 = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt2 / c;
    } else {
      value += rt2 * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b)
      return 0;
    let x2 = a.length;
    let y = b.length;
    for (let i = 0, len = Math.min(x2, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x2 = a[i];
        y = b[i];
        break;
      }
    }
    if (x2 < y)
      return -1;
    if (y < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf))
            buf = Buffer2.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m2) {
    const i = b[n];
    b[n] = b[m2];
    b[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    let str = "";
    const max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x2, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x2 < y)
      return -1;
    if (y < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
function ze(l2, a) {
  (a == null || a > l2.length) && (a = l2.length);
  for (var e = 0, r = Array(a); e < a; e++)
    r[e] = l2[e];
  return r;
}
function xe(l2) {
  if (Array.isArray(l2))
    return l2;
}
function er(l2) {
  if (l2 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return l2;
}
function fe(l2) {
  var a, e, r, t = 2;
  for (typeof Symbol < "u" && (e = Symbol.asyncIterator, r = Symbol.iterator); t--; ) {
    if (e && (a = l2[e]) != null)
      return a.call(l2);
    if (r && (a = l2[r]) != null)
      return new he(a.call(l2));
    e = "@@asyncIterator", r = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function he(l2) {
  function a(e) {
    if (Object(e) !== e)
      return Promise.reject(new TypeError(e + " is not an object."));
    var r = e.done;
    return Promise.resolve(e.value).then(function(t) {
      return {
        value: t,
        done: r
      };
    });
  }
  return he = function(e) {
    this.s = e, this.n = e.next;
  }, he.prototype = {
    s: null,
    n: null,
    next: function() {
      return a(this.n.apply(this.s, arguments));
    },
    return: function(e) {
      var r = this.s.return;
      return r === void 0 ? Promise.resolve({
        value: e,
        done: true
      }) : a(r.apply(this.s, arguments));
    },
    throw: function(e) {
      var r = this.s.return;
      return r === void 0 ? Promise.reject(e) : a(r.apply(this.s, arguments));
    }
  }, new he(l2);
}
function Ee(l2, a, e, r, t, s, n) {
  try {
    var u = l2[s](n), i = u.value;
  } catch (f) {
    return void e(f);
  }
  u.done ? a(i) : Promise.resolve(i).then(r, t);
}
function m(l2) {
  return function() {
    var a = this, e = arguments;
    return new Promise(function(r, t) {
      var s = l2.apply(a, e);
      function n(i) {
        Ee(s, r, t, n, u, "next", i);
      }
      function u(i) {
        Ee(s, r, t, n, u, "throw", i);
      }
      n(void 0);
    });
  };
}
function rr(l2, a, e) {
  return a = ve(a), ir(l2, We() ? Reflect.construct(a, [], ve(l2).constructor) : a.apply(l2, e));
}
function R(l2, a) {
  if (!(l2 instanceof a))
    throw new TypeError("Cannot call a class as a function");
}
function Te(l2, a) {
  for (var e = 0; e < a.length; e++) {
    var r = a[e];
    r.enumerable = r.enumerable || false, r.configurable = true, "value" in r && (r.writable = true), Object.defineProperty(l2, Re(r.key), r);
  }
}
function H(l2, a, e) {
  return a && Te(l2.prototype, a), e && Te(l2, e), Object.defineProperty(l2, "prototype", {
    writable: false
  }), l2;
}
function G(l2, a) {
  var e = typeof Symbol < "u" && l2[Symbol.iterator] || l2["@@iterator"];
  if (!e) {
    if (Array.isArray(l2) || (e = He(l2)) || a) {
      e && (l2 = e);
      var r = 0, t = function() {
      };
      return {
        s: t,
        n: function() {
          return r >= l2.length ? {
            done: true
          } : {
            done: false,
            value: l2[r++]
          };
        },
        e: function(i) {
          throw i;
        },
        f: t
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s, n = true, u = false;
  return {
    s: function() {
      e = e.call(l2);
    },
    n: function() {
      var i = e.next();
      return n = i.done, i;
    },
    e: function(i) {
      u = true, s = i;
    },
    f: function() {
      try {
        n || e.return == null || e.return();
      } finally {
        if (u)
          throw s;
      }
    }
  };
}
function pe(l2, a, e) {
  return (a = Re(a)) in l2 ? Object.defineProperty(l2, a, {
    value: e,
    enumerable: true,
    configurable: true,
    writable: true
  }) : l2[a] = e, l2;
}
function ve(l2) {
  return ve = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(a) {
    return a.__proto__ || Object.getPrototypeOf(a);
  }, ve(l2);
}
function tr(l2, a) {
  if (typeof a != "function" && a !== null)
    throw new TypeError("Super expression must either be null or a function");
  l2.prototype = Object.create(a && a.prototype, {
    constructor: {
      value: l2,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(l2, "prototype", {
    writable: false
  }), a && ge(l2, a);
}
function We() {
  try {
    var l2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (We = function() {
    return !!l2;
  })();
}
function nr(l2, a) {
  var e = l2 == null ? null : typeof Symbol < "u" && l2[Symbol.iterator] || l2["@@iterator"];
  if (e != null) {
    var r, t, s, n, u = [], i = true, f = false;
    try {
      if (s = (e = e.call(l2)).next, a === 0) {
        if (Object(e) !== e)
          return;
        i = false;
      } else
        for (; !(i = (r = s.call(e)).done) && (u.push(r.value), u.length !== a); i = true)
          ;
    } catch (h) {
      f = true, t = h;
    } finally {
      try {
        if (!i && e.return != null && (n = e.return(), Object(n) !== n))
          return;
      } finally {
        if (f)
          throw t;
      }
    }
    return u;
  }
}
function ar() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ir(l2, a) {
  if (a && (typeof a == "object" || typeof a == "function"))
    return a;
  if (a !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return er(l2);
}
function p() {
  p = function() {
    return a;
  };
  var l2, a = {}, e = Object.prototype, r = e.hasOwnProperty, t = Object.defineProperty || function(w2, o, C) {
    w2[o] = C.value;
  }, s = typeof Symbol == "function" ? Symbol : {}, n = s.iterator || "@@iterator", u = s.asyncIterator || "@@asyncIterator", i = s.toStringTag || "@@toStringTag";
  function f(w2, o, C) {
    return Object.defineProperty(w2, o, {
      value: C,
      enumerable: true,
      configurable: true,
      writable: true
    }), w2[o];
  }
  try {
    f({}, "");
  } catch {
    f = function(o, C, z2) {
      return o[C] = z2;
    };
  }
  function h(w2, o, C, z2) {
    var F = o && o.prototype instanceof P2 ? o : P2, E2 = Object.create(F.prototype), M2 = new ke(z2 || []);
    return t(E2, "_invoke", {
      value: X2(w2, C, M2)
    }), E2;
  }
  function d(w2, o, C) {
    try {
      return {
        type: "normal",
        arg: w2.call(o, C)
      };
    } catch (z2) {
      return {
        type: "throw",
        arg: z2
      };
    }
  }
  a.wrap = h;
  var c = "suspendedStart", v2 = "suspendedYield", k2 = "executing", b = "completed", y = {};
  function P2() {
  }
  function g() {
  }
  function $2() {
  }
  var S2 = {};
  f(S2, n, function() {
    return this;
  });
  var L2 = Object.getPrototypeOf, T = L2 && L2(L2(me2([])));
  T && T !== e && r.call(T, n) && (S2 = T);
  var q2 = $2.prototype = P2.prototype = Object.create(S2);
  function D2(w2) {
    ["next", "throw", "return"].forEach(function(o) {
      f(w2, o, function(C) {
        return this._invoke(o, C);
      });
    });
  }
  function Y2(w2, o) {
    function C(F, E2, M2, I2) {
      var A2 = d(w2[F], w2, E2);
      if (A2.type !== "throw") {
        var ee = A2.arg, se2 = ee.value;
        return se2 && typeof se2 == "object" && r.call(se2, "__await") ? o.resolve(se2.__await).then(function(Q2) {
          C("next", Q2, M2, I2);
        }, function(Q2) {
          C("throw", Q2, M2, I2);
        }) : o.resolve(se2).then(function(Q2) {
          ee.value = Q2, M2(ee);
        }, function(Q2) {
          return C("throw", Q2, M2, I2);
        });
      }
      I2(A2.arg);
    }
    var z2;
    t(this, "_invoke", {
      value: function(F, E2) {
        function M2() {
          return new o(function(I2, A2) {
            C(F, E2, I2, A2);
          });
        }
        return z2 = z2 ? z2.then(M2, M2) : M2();
      }
    });
  }
  function X2(w2, o, C) {
    var z2 = c;
    return function(F, E2) {
      if (z2 === k2)
        throw Error("Generator is already running");
      if (z2 === b) {
        if (F === "throw")
          throw E2;
        return {
          value: l2,
          done: true
        };
      }
      for (C.method = F, C.arg = E2; ; ) {
        var M2 = C.delegate;
        if (M2) {
          var I2 = ie(M2, C);
          if (I2) {
            if (I2 === y)
              continue;
            return I2;
          }
        }
        if (C.method === "next")
          C.sent = C._sent = C.arg;
        else if (C.method === "throw") {
          if (z2 === c)
            throw z2 = b, C.arg;
          C.dispatchException(C.arg);
        } else
          C.method === "return" && C.abrupt("return", C.arg);
        z2 = k2;
        var A2 = d(w2, o, C);
        if (A2.type === "normal") {
          if (z2 = C.done ? b : v2, A2.arg === y)
            continue;
          return {
            value: A2.arg,
            done: C.done
          };
        }
        A2.type === "throw" && (z2 = b, C.method = "throw", C.arg = A2.arg);
      }
    };
  }
  function ie(w2, o) {
    var C = o.method, z2 = w2.iterator[C];
    if (z2 === l2)
      return o.delegate = null, C === "throw" && w2.iterator.return && (o.method = "return", o.arg = l2, ie(w2, o), o.method === "throw") || C !== "return" && (o.method = "throw", o.arg = new TypeError("The iterator does not provide a '" + C + "' method")), y;
    var F = d(z2, w2.iterator, o.arg);
    if (F.type === "throw")
      return o.method = "throw", o.arg = F.arg, o.delegate = null, y;
    var E2 = F.arg;
    return E2 ? E2.done ? (o[w2.resultName] = E2.value, o.next = w2.nextLoc, o.method !== "return" && (o.method = "next", o.arg = l2), o.delegate = null, y) : E2 : (o.method = "throw", o.arg = new TypeError("iterator result is not an object"), o.delegate = null, y);
  }
  function Ce(w2) {
    var o = {
      tryLoc: w2[0]
    };
    1 in w2 && (o.catchLoc = w2[1]), 2 in w2 && (o.finallyLoc = w2[2], o.afterLoc = w2[3]), this.tryEntries.push(o);
  }
  function O2(w2) {
    var o = w2.completion || {};
    o.type = "normal", delete o.arg, w2.completion = o;
  }
  function ke(w2) {
    this.tryEntries = [{
      tryLoc: "root"
    }], w2.forEach(Ce, this), this.reset(true);
  }
  function me2(w2) {
    if (w2 || w2 === "") {
      var o = w2[n];
      if (o)
        return o.call(w2);
      if (typeof w2.next == "function")
        return w2;
      if (!isNaN(w2.length)) {
        var C = -1, z2 = function F() {
          for (; ++C < w2.length; )
            if (r.call(w2, C))
              return F.value = w2[C], F.done = false, F;
          return F.value = l2, F.done = true, F;
        };
        return z2.next = z2;
      }
    }
    throw new TypeError(typeof w2 + " is not iterable");
  }
  return g.prototype = $2, t(q2, "constructor", {
    value: $2,
    configurable: true
  }), t($2, "constructor", {
    value: g,
    configurable: true
  }), g.displayName = f($2, i, "GeneratorFunction"), a.isGeneratorFunction = function(w2) {
    var o = typeof w2 == "function" && w2.constructor;
    return !!o && (o === g || (o.displayName || o.name) === "GeneratorFunction");
  }, a.mark = function(w2) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(w2, $2) : (w2.__proto__ = $2, f(w2, i, "GeneratorFunction")), w2.prototype = Object.create(q2), w2;
  }, a.awrap = function(w2) {
    return {
      __await: w2
    };
  }, D2(Y2.prototype), f(Y2.prototype, u, function() {
    return this;
  }), a.AsyncIterator = Y2, a.async = function(w2, o, C, z2, F) {
    F === void 0 && (F = Promise);
    var E2 = new Y2(h(w2, o, C, z2), F);
    return a.isGeneratorFunction(o) ? E2 : E2.next().then(function(M2) {
      return M2.done ? M2.value : E2.next();
    });
  }, D2(q2), f(q2, i, "Generator"), f(q2, n, function() {
    return this;
  }), f(q2, "toString", function() {
    return "[object Generator]";
  }), a.keys = function(w2) {
    var o = Object(w2), C = [];
    for (var z2 in o)
      C.push(z2);
    return C.reverse(), function F() {
      for (; C.length; ) {
        var E2 = C.pop();
        if (E2 in o)
          return F.value = E2, F.done = false, F;
      }
      return F.done = true, F;
    };
  }, a.values = me2, ke.prototype = {
    constructor: ke,
    reset: function(w2) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = l2, this.done = false, this.delegate = null, this.method = "next", this.arg = l2, this.tryEntries.forEach(O2), !w2)
        for (var o in this)
          o.charAt(0) === "t" && r.call(this, o) && !isNaN(+o.slice(1)) && (this[o] = l2);
    },
    stop: function() {
      this.done = true;
      var w2 = this.tryEntries[0].completion;
      if (w2.type === "throw")
        throw w2.arg;
      return this.rval;
    },
    dispatchException: function(w2) {
      if (this.done)
        throw w2;
      var o = this;
      function C(A2, ee) {
        return E2.type = "throw", E2.arg = w2, o.next = A2, ee && (o.method = "next", o.arg = l2), !!ee;
      }
      for (var z2 = this.tryEntries.length - 1; z2 >= 0; --z2) {
        var F = this.tryEntries[z2], E2 = F.completion;
        if (F.tryLoc === "root")
          return C("end");
        if (F.tryLoc <= this.prev) {
          var M2 = r.call(F, "catchLoc"), I2 = r.call(F, "finallyLoc");
          if (M2 && I2) {
            if (this.prev < F.catchLoc)
              return C(F.catchLoc, true);
            if (this.prev < F.finallyLoc)
              return C(F.finallyLoc);
          } else if (M2) {
            if (this.prev < F.catchLoc)
              return C(F.catchLoc, true);
          } else {
            if (!I2)
              throw Error("try statement without catch or finally");
            if (this.prev < F.finallyLoc)
              return C(F.finallyLoc);
          }
        }
      }
    },
    abrupt: function(w2, o) {
      for (var C = this.tryEntries.length - 1; C >= 0; --C) {
        var z2 = this.tryEntries[C];
        if (z2.tryLoc <= this.prev && r.call(z2, "finallyLoc") && this.prev < z2.finallyLoc) {
          var F = z2;
          break;
        }
      }
      F && (w2 === "break" || w2 === "continue") && F.tryLoc <= o && o <= F.finallyLoc && (F = null);
      var E2 = F ? F.completion : {};
      return E2.type = w2, E2.arg = o, F ? (this.method = "next", this.next = F.finallyLoc, y) : this.complete(E2);
    },
    complete: function(w2, o) {
      if (w2.type === "throw")
        throw w2.arg;
      return w2.type === "break" || w2.type === "continue" ? this.next = w2.arg : w2.type === "return" ? (this.rval = this.arg = w2.arg, this.method = "return", this.next = "end") : w2.type === "normal" && o && (this.next = o), y;
    },
    finish: function(w2) {
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var C = this.tryEntries[o];
        if (C.finallyLoc === w2)
          return this.complete(C.completion, C.afterLoc), O2(C), y;
      }
    },
    catch: function(w2) {
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var C = this.tryEntries[o];
        if (C.tryLoc === w2) {
          var z2 = C.completion;
          if (z2.type === "throw") {
            var F = z2.arg;
            O2(C);
          }
          return F;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(w2, o, C) {
      return this.delegate = {
        iterator: me2(w2),
        resultName: o,
        nextLoc: C
      }, this.method === "next" && (this.arg = l2), y;
    }
  }, a;
}
function ge(l2, a) {
  return ge = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, r) {
    return e.__proto__ = r, e;
  }, ge(l2, a);
}
function U$1(l2, a) {
  return xe(l2) || nr(l2, a) || He(l2, a) || ar();
}
function sr(l2, a) {
  if (typeof l2 != "object" || !l2)
    return l2;
  var e = l2[Symbol.toPrimitive];
  if (e !== void 0) {
    var r = e.call(l2, a);
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(l2);
}
function Re(l2) {
  var a = sr(l2, "string");
  return typeof a == "symbol" ? a : a + "";
}
function He(l2, a) {
  if (l2) {
    if (typeof l2 == "string")
      return ze(l2, a);
    var e = {}.toString.call(l2).slice(8, -1);
    return e === "Object" && l2.constructor && (e = l2.constructor.name), e === "Map" || e === "Set" ? Array.from(l2) : e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e) ? ze(l2, a) : void 0;
  }
}
var _ = _e;
function ur(l2) {
  if (l2 = j(l2), !l2)
    return [[], ""];
  var a = l2.split("/");
  a[0] === "" && a.shift();
  var e = a.pop();
  return [a, e];
}
function j(l2) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  return l2 = l2.trim(), l2 = l2.replace(/(^\/*)|(\/*$)/g, ""), l2 = l2.replace(/\/+/g, "/"), l2 ? (l2 = "/".concat(l2), a ? "".concat(l2, "/") : l2) : "/";
}
function Z$1(l2) {
  return ce$1(l2).parent;
}
function lr(l2) {
  return Ue(l2, "/");
}
function Ue(l2, a) {
  l2 = j(l2);
  var e = l2.lastIndexOf(a);
  return e === -1 ? l2 : l2.substring(e + 1);
}
function de(l2, a, e, r) {
  var t = new Set(e), s = {}, n = G(l2), u;
  try {
    for (n.s(); !(u = n.n()).done; ) {
      var i = u.value, f = (r == null ? void 0 : r[i]) || i, h = ce$1(f), d = h.name, c = t.has(d) ? fr(d, t) : d;
      t.add(c), s[i] = _.join(a, c);
    }
  } catch (v2) {
    n.e(v2);
  } finally {
    n.f();
  }
  return s;
}
function fr(l2, a) {
  for (; a.has(l2); ) {
    var e = l2.match(/(\((\d+)\))?(\..*)?$/);
    if (!e) {
      l2 = "".concat(l2, "(1)");
      break;
    }
    var r = U$1(e, 3), t = r[0], s = r[1], n = r[2];
    if (!t)
      l2 = "".concat(l2, "(1)");
    else {
      var u = "";
      n ? u = t.replace(s, "(".concat(parseInt(n) + 1, ")")) : u = "(1)".concat(t), l2 = l2.replace(t, u);
    }
  }
  return l2;
}
function cr(l2, a) {
  l2.endsWith("/") && (l2 = l2.substring(0, l2.length - 1));
  var e = new RegExp("^".concat(l2, "/([^/]+)")), r = a.match(e);
  return r ? "".concat(l2, "/").concat(r[1]) : "";
}
var hr = "_$*%#@♧⊙";
function oe(l2) {
  var a = "".concat(l2, "-").concat(hr), e = ge$1(a);
  return {
    data: e,
    length: e.byteLength
  };
}
var Ze = function() {
  return oe("dir");
}, Ge = Ze(), Ne = Ge.data;
var qe = oe("link"), $e = qe.data, Ye = qe.length;
function B$1(l2) {
  return l2 ? ye(l2, Ne) ? "dir" : Ke(l2, $e) ? "link" : "file" : "empty";
}
function Ke(l2, a) {
  var e = a.byteLength;
  return !!(l2.byteLength >= e && ye(l2.slice(0, e), a));
}
function ne(l2, a) {
  if (l2 === "empty")
    return new Uint8Array([]);
  if (l2 === "dir")
    return de$1(Ne);
  var e = typeof a == "string" ? ge$1(
    l2 === "link" ? j(a) : a
    // ! link 存储的是路径 需要clearPath
  ) : a;
  return l2 === "link" ? ve$1($e, e) : e;
}
function pr(l2) {
  return we$1(l2.slice(Ye));
}
var Me = /* @__PURE__ */ function() {
  function l2() {
    R(this, l2);
  }
  return H(l2, [{
    key: "init",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        var t, s, n, u, i;
        return p().wrap(function(h) {
          for (; ; )
            switch (h.prev = h.next) {
              case 0:
                return h.next = 2, navigator.permissions.query({
                  name: "persistent-storage"
                });
              case 2:
                return h.next = 4, navigator.storage.estimate();
              case 4:
                if (t = h.sent, s = t.usage, n = s === void 0 ? 0 : s, u = t.quota, i = u === void 0 ? 0 : u, !(n >= i)) {
                  h.next = 11;
                  break;
                }
                throw new Error("存储空间不足");
              case 11:
                return h.next = 13, navigator.storage.getDirectory();
              case 13:
                this.root = h.sent;
              case 14:
              case "end":
                return h.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 读取文件内容，path为绝对路径
  }, {
    key: "read",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return i.next = 2, this.getHandleByPath(t);
              case 2:
                if (s = i.sent, n = s.file, n) {
                  i.next = 6;
                  break;
                }
                return i.abrupt("return", null);
              case 6:
                return i.abrupt("return", this._readFile(n));
              case 7:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 写入内容到文件，path为绝对路径
  }, {
    key: "write",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u;
        return p().wrap(function(f) {
          for (; ; )
            switch (f.prev = f.next) {
              case 0:
                return f.next = 2, this.getHandleByPath(t);
              case 2:
                if (n = f.sent, u = n.file, u) {
                  f.next = 6;
                  break;
                }
                return f.abrupt("return", false);
              case 6:
                return f.next = 8, this._writeFile(u, s);
              case 8:
                return f.abrupt("return", true);
              case 9:
              case "end":
                return f.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_writeFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return i.next = 2, t.createWritable();
              case 2:
                return n = i.sent, i.next = 5, n.write(s);
              case 5:
                return i.next = 7, n.close();
              case 7:
              case "end":
                return i.stop();
            }
        }, r);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 追加内容到文件，path为绝对路径
  }, {
    key: "append",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f;
        return p().wrap(function(d) {
          for (; ; )
            switch (d.prev = d.next) {
              case 0:
                return d.next = 2, this.getHandleByPath(t);
              case 2:
                if (n = d.sent, u = n.file, u) {
                  d.next = 6;
                  break;
                }
                return d.abrupt("return", false);
              case 6:
                return d.next = 8, u.createWritable();
              case 8:
                return i = d.sent, d.next = 11, this._readFile(u);
              case 11:
                return f = d.sent, d.next = 14, i.write(f);
              case 14:
                return d.next = 16, i.write({
                  type: "write",
                  position: f.byteLength,
                  data: s
                });
              case 16:
                return d.next = 18, i.close();
              case 18:
                return d.abrupt("return", true);
              case 19:
              case "end":
                return d.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 移除文件，path为绝对路径
  }, {
    key: "remove",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                return c.next = 2, this.getParentByPath(t);
              case 2:
                if (s = c.sent, n = s.name, u = s.dir, u) {
                  c.next = 7;
                  break;
                }
                return c.abrupt("return", false);
              case 7:
                return c.next = 9, me(u.removeEntry(n, {
                  recursive: true
                }));
              case 9:
                return i = c.sent, f = U$1(i, 2), h = f[1], c.abrupt("return", !h);
              case 13:
              case "end":
                return c.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "stat",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h, d, c, v2 = arguments;
        return p().wrap(function(b) {
          for (; ; )
            switch (b.prev = b.next) {
              case 0:
                return s = v2.length > 1 && v2[1] !== void 0 ? v2[1] : true, b.next = 3, this.getHandleByPath(t);
              case 3:
                if (n = b.sent, u = n.type, i = n.file, f = n.dir, u !== "empty") {
                  b.next = 9;
                  break;
                }
                return b.abrupt("return", {
                  size: 0,
                  type: u
                });
              case 9:
                if (h = 0, u !== "file") {
                  b.next = 21;
                  break;
                }
                return b.next = 13, i.getFile();
              case 13:
                return d = b.sent, h = d.size, b.next = 17, this._isLinkFile(d);
              case 17:
                if (!b.sent) {
                  b.next = 19;
                  break;
                }
                return b.abrupt("return", {
                  type: "link",
                  size: h
                });
              case 19:
                b.next = 27;
                break;
              case 21:
                if (!s) {
                  b.next = 27;
                  break;
                }
                return c = [], b.next = 25, this.traverse(f, function(y) {
                  c.push(m(/* @__PURE__ */ p().mark(function P2() {
                    return p().wrap(function($2) {
                      for (; ; )
                        switch ($2.prev = $2.next) {
                          case 0:
                            return $2.t0 = h, $2.next = 3, y.getFile();
                          case 3:
                            h = $2.t0 += $2.sent.size;
                          case 4:
                          case "end":
                            return $2.stop();
                        }
                    }, P2);
                  }))());
                });
              case 25:
                return b.next = 27, Promise.all(c);
              case 27:
                return b.abrupt("return", {
                  type: u,
                  size: h
                });
              case 28:
              case "end":
                return b.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_isLinkFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                if (s = t.size, s !== Ye) {
                  i.next = 9;
                  break;
                }
                return i.t0 = Uint8Array, i.next = 5, t.arrayBuffer();
              case 5:
                if (i.t1 = i.sent, n = new i.t0(i.t1), !ye(n, $e)) {
                  i.next = 9;
                  break;
                }
                return i.abrupt("return", true);
              case 9:
                return i.abrupt("return", false);
              case 10:
              case "end":
                return i.stop();
            }
        }, r);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "traverse",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h, d;
        return p().wrap(function(v2) {
          for (; ; )
            switch (v2.prev = v2.next) {
              case 0:
                n = false, u = false, v2.prev = 2, f = fe(t.entries());
              case 4:
                return v2.next = 6, f.next();
              case 6:
                if (!(n = !(h = v2.sent).done)) {
                  v2.next = 17;
                  break;
                }
                if (d = h.value, d[1].kind !== "directory") {
                  v2.next = 13;
                  break;
                }
                return v2.next = 11, this.traverse(d[1], s);
              case 11:
                v2.next = 14;
                break;
              case 13:
                s(d[1], d[0]);
              case 14:
                n = false, v2.next = 4;
                break;
              case 17:
                v2.next = 23;
                break;
              case 19:
                v2.prev = 19, v2.t0 = v2.catch(2), u = true, i = v2.t0;
              case 23:
                if (v2.prev = 23, v2.prev = 24, !(n && f.return != null)) {
                  v2.next = 28;
                  break;
                }
                return v2.next = 28, f.return();
              case 28:
                if (v2.prev = 28, !u) {
                  v2.next = 31;
                  break;
                }
                throw i;
              case 31:
                return v2.finish(28);
              case 32:
                return v2.finish(23);
              case 33:
              case "end":
                return v2.stop();
            }
        }, r, this, [[2, 19, 23, 33], [24, , 28, 32]]);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // content = null 表示为 目录
  }, {
    key: "traverseContent",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h = arguments;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                if (s = h.length > 1 && h[1] !== void 0 ? h[1] : "", n = h.length > 2 && h[2] !== void 0 ? h[2] : true, s) {
                  c.next = 6;
                  break;
                }
                u = this.root, c.next = 13;
                break;
              case 6:
                return c.next = 8, this.getHandleByPath(s);
              case 8:
                if (i = c.sent, f = i.dir, f) {
                  c.next = 12;
                  break;
                }
                throw new Error("dir not found: ".concat(s));
              case 12:
                u = f;
              case 13:
                return c.next = 15, this._traverseContent(s, u, t, n);
              case 15:
              case "end":
                return c.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_traverseContent",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s, n, u) {
        var i, f, h, d, c, v2, k2, b, y, P2;
        return p().wrap(function($2) {
          for (; ; )
            switch ($2.prev = $2.next) {
              case 0:
                i = false, f = false, $2.prev = 2, d = fe(s.entries());
              case 4:
                return $2.next = 6, d.next();
              case 6:
                if (!(i = !(c = $2.sent).done)) {
                  $2.next = 22;
                  break;
                }
                if (v2 = c.value, k2 = U$1(v2, 2), b = k2[0], y = k2[1], P2 = "".concat(t, "/").concat(b), y.kind !== "directory") {
                  $2.next = 17;
                  break;
                }
                return $2.next = 13, n(P2, Promise.resolve(null), b);
              case 13:
                return $2.next = 15, this._traverseContent(P2, y, n, u);
              case 15:
                $2.next = 19;
                break;
              case 17:
                return $2.next = 19, n(P2, u ? this._readFile(y) : Promise.resolve(null), b);
              case 19:
                i = false, $2.next = 4;
                break;
              case 22:
                $2.next = 28;
                break;
              case 24:
                $2.prev = 24, $2.t0 = $2.catch(2), f = true, h = $2.t0;
              case 28:
                if ($2.prev = 28, $2.prev = 29, !(i && d.return != null)) {
                  $2.next = 33;
                  break;
                }
                return $2.next = 33, d.return();
              case 33:
                if ($2.prev = 33, !f) {
                  $2.next = 36;
                  break;
                }
                throw h;
              case 36:
                return $2.finish(33);
              case 37:
                return $2.finish(28);
              case 38:
              case "end":
                return $2.stop();
            }
        }, r, this, [[2, 24, 28, 38], [29, , 33, 37]]);
      }));
      function e(r, t, s, n) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 检查文件是否存在，path为绝对路径
  }, {
    key: "exist",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return i.next = 2, this.getHandleByPath(t);
              case 2:
                return s = i.sent, n = s.type, i.abrupt("return", n !== "empty");
              case 5:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 查看目录下的文件列表，path为绝对路径
  }, {
    key: "ls",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h, d, c, v2, k2;
        return p().wrap(function(y) {
          for (; ; )
            switch (y.prev = y.next) {
              case 0:
                return y.next = 2, this.getHandleByPath(t);
              case 2:
                if (s = y.sent, n = s.type, u = s.dir, n === "dir") {
                  y.next = 7;
                  break;
                }
                return y.abrupt("return", null);
              case 7:
                i = [], f = false, h = false, y.prev = 10, c = fe(u.keys());
              case 12:
                return y.next = 14, c.next();
              case 14:
                if (!(f = !(v2 = y.sent).done)) {
                  y.next = 20;
                  break;
                }
                k2 = v2.value, i.push(k2);
              case 17:
                f = false, y.next = 12;
                break;
              case 20:
                y.next = 26;
                break;
              case 22:
                y.prev = 22, y.t0 = y.catch(10), h = true, d = y.t0;
              case 26:
                if (y.prev = 26, y.prev = 27, !(f && c.return != null)) {
                  y.next = 31;
                  break;
                }
                return y.next = 31, c.return();
              case 31:
                if (y.prev = 31, !h) {
                  y.next = 34;
                  break;
                }
                throw d;
              case 34:
                return y.finish(31);
              case 35:
                return y.finish(26);
              case 36:
                return y.abrupt("return", i);
              case 37:
              case "end":
                return y.stop();
            }
        }, r, this, [[10, 22, 26, 36], [27, , 31, 35]]);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "existInDir",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h, d;
        return p().wrap(function(v2) {
          for (; ; )
            switch (v2.prev = v2.next) {
              case 0:
                n = false, u = false, v2.prev = 2, f = fe(s.keys());
              case 4:
                return v2.next = 6, f.next();
              case 6:
                if (!(n = !(h = v2.sent).done)) {
                  v2.next = 13;
                  break;
                }
                if (d = h.value, t !== d) {
                  v2.next = 10;
                  break;
                }
                return v2.abrupt("return", true);
              case 10:
                n = false, v2.next = 4;
                break;
              case 13:
                v2.next = 19;
                break;
              case 15:
                v2.prev = 15, v2.t0 = v2.catch(2), u = true, i = v2.t0;
              case 19:
                if (v2.prev = 19, v2.prev = 20, !(n && f.return != null)) {
                  v2.next = 24;
                  break;
                }
                return v2.next = 24, f.return();
              case 24:
                if (v2.prev = 24, !u) {
                  v2.next = 27;
                  break;
                }
                throw i;
              case 27:
                return v2.finish(24);
              case 28:
                return v2.finish(19);
              case 29:
                return v2.abrupt("return", false);
              case 30:
              case "end":
                return v2.stop();
            }
        }, r, null, [[2, 15, 19, 29], [20, , 24, 28]]);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createLink",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u = arguments;
        return p().wrap(function(f) {
          for (; ; )
            switch (f.prev = f.next) {
              case 0:
                return n = u.length > 2 && u[2] !== void 0 ? u[2] : false, f.abrupt("return", this.createFile(t, ne("link", s), n));
              case 2:
              case "end":
                return f.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h, d = arguments;
        return p().wrap(function(v2) {
          for (; ; )
            switch (v2.prev = v2.next) {
              case 0:
                return n = d.length > 2 && d[2] !== void 0 ? d[2] : false, v2.next = 3, this.clearTarget(t, n);
              case 3:
                if (u = v2.sent, i = u.dir, f = u.name, i) {
                  v2.next = 8;
                  break;
                }
                return v2.abrupt("return", false);
              case 8:
                return v2.next = 10, i.getFileHandle(f, {
                  create: true
                });
              case 10:
                if (h = v2.sent, !s) {
                  v2.next = 14;
                  break;
                }
                return v2.next = 14, this._writeFile(h, s);
              case 14:
                return v2.abrupt("return", true);
              case 15:
              case "end":
                return v2.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createDir",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f = arguments;
        return p().wrap(function(d) {
          for (; ; )
            switch (d.prev = d.next) {
              case 0:
                return s = f.length > 1 && f[1] !== void 0 ? f[1] : false, d.next = 3, this.clearTarget(t, s);
              case 3:
                if (n = d.sent, u = n.dir, i = n.name, u) {
                  d.next = 8;
                  break;
                }
                return d.abrupt("return", false);
              case 8:
                return d.next = 10, u.getDirectoryHandle(i, {
                  create: true
                });
              case 10:
                return d.abrupt("return", true);
              case 11:
              case "end":
                return d.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "clearTarget",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i;
        return p().wrap(function(h) {
          for (; ; )
            switch (h.prev = h.next) {
              case 0:
                return h.next = 2, this.getParentByPath(t);
              case 2:
                if (n = h.sent, u = n.name, i = n.dir, i) {
                  h.next = 7;
                  break;
                }
                return h.abrupt("return", {
                  dir: null,
                  name: u
                });
              case 7:
                return h.next = 9, this.existInDir(u, i);
              case 9:
                if (!h.sent) {
                  h.next = 16;
                  break;
                }
                if (!s) {
                  h.next = 15;
                  break;
                }
                return h.next = 13, i.removeEntry(u, {
                  recursive: true
                });
              case 13:
                h.next = 16;
                break;
              case 15:
                return h.abrupt("return", {
                  dir: null,
                  name: u
                });
              case 16:
                return h.abrupt("return", {
                  dir: i,
                  name: u
                });
              case 17:
              case "end":
                return h.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_readFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return u.next = 2, t.getFile();
              case 2:
                return s = u.sent, u.t0 = Uint8Array, u.next = 6, s.arrayBuffer();
              case 6:
                return u.t1 = u.sent, u.abrupt("return", new u.t0(u.t1));
              case 8:
              case "end":
                return u.stop();
            }
        }, r);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "getHandleByPath",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h, d, c, v2, k2, b;
        return p().wrap(function(P2) {
          for (; ; )
            switch (P2.prev = P2.next) {
              case 0:
                if (t !== "/") {
                  P2.next = 2;
                  break;
                }
                return P2.abrupt("return", {
                  type: "dir",
                  dir: this.root
                });
              case 2:
                return P2.next = 4, this.getParentByPath(t);
              case 4:
                if (s = P2.sent, n = s.name, u = s.dir, u) {
                  P2.next = 9;
                  break;
                }
                return P2.abrupt("return", {
                  type: "empty"
                });
              case 9:
                return P2.next = 11, me(u.getFileHandle(n));
              case 11:
                if (i = P2.sent, f = U$1(i, 2), h = f[0], d = f[1], !d) {
                  P2.next = 27;
                  break;
                }
                return P2.next = 18, me(u.getDirectoryHandle(n));
              case 18:
                if (c = P2.sent, v2 = U$1(c, 2), k2 = v2[0], b = v2[1], !b) {
                  P2.next = 24;
                  break;
                }
                return P2.abrupt("return", {
                  type: "empty"
                });
              case 24:
                return P2.abrupt("return", {
                  type: "dir",
                  dir: k2
                });
              case 27:
                return P2.abrupt("return", {
                  type: "file",
                  file: h
                });
              case 28:
              case "end":
                return P2.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "getParentByPath",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h, d, c, v2, k2, b, y;
        return p().wrap(function(g) {
          for (; ; )
            switch (g.prev = g.next) {
              case 0:
                if (s = ur(t), n = U$1(s, 2), u = n[0], i = n[1], i) {
                  g.next = 3;
                  break;
                }
                return g.abrupt("return", {
                  name: i
                });
              case 3:
                f = this.root, h = G(u), g.prev = 5, h.s();
              case 7:
                if ((d = h.n()).done) {
                  g.next = 20;
                  break;
                }
                return c = d.value, g.next = 11, me(f.getDirectoryHandle(c));
              case 11:
                if (v2 = g.sent, k2 = U$1(v2, 2), b = k2[0], y = k2[1], !y) {
                  g.next = 17;
                  break;
                }
                return g.abrupt("return", {
                  name: c
                });
              case 17:
                f = b;
              case 18:
                g.next = 7;
                break;
              case 20:
                g.next = 25;
                break;
              case 22:
                g.prev = 22, g.t0 = g.catch(5), h.e(g.t0);
              case 25:
                return g.prev = 25, h.f(), g.finish(25);
              case 28:
                return g.abrupt("return", {
                  name: i,
                  dir: f
                });
              case 29:
              case "end":
                return g.stop();
            }
        }, r, this, [[5, 22, 25, 28]]);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "getType",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return i.next = 2, this.getHandleByPath(t);
              case 2:
                return s = i.sent, n = s.type, i.abrupt("return", n);
              case 5:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }], [{
    key: "Supported",
    value: function() {
      return typeof navigator.storage < "u" && typeof FileSystemWritableFileStream < "u";
    }
  }]);
}(), Le = /* @__PURE__ */ function() {
  function l2() {
    R(this, l2);
  }
  return H(l2, [{
    key: "traverseContent",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h, d = arguments;
        return p().wrap(function(v2) {
          for (; ; )
            switch (v2.prev = v2.next) {
              case 0:
                return s = d.length > 1 && d[1] !== void 0 ? d[1] : "", n = d.length > 2 && d[2] !== void 0 ? d[2] : true, v2.next = 4, R$2.keys();
              case 4:
                u = v2.sent, i = G(u);
                try {
                  for (i.s(); !(f = i.n()).done; )
                    h = f.value, h.startsWith(s) && t(h, n ? R$2.getItem(h) : Promise.resolve(null), ce$1(h).name);
                } catch (k2) {
                  i.e(k2);
                } finally {
                  i.f();
                }
              case 7:
              case "end":
                return v2.stop();
            }
        }, r);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "init",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        return p().wrap(function(s) {
          for (; ; )
            switch (s.prev = s.next) {
              case 0:
                return s.next = 2, R$2.ready();
              case 2:
              case "end":
                return s.stop();
            }
        }, r);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "read",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return i.next = 2, R$2.getItem(j(t));
              case 2:
                if (s = i.sent, n = B$1(s), !(n === "empty" || n === "dir")) {
                  i.next = 6;
                  break;
                }
                return i.abrupt("return", null);
              case 6:
                return i.abrupt("return", s);
              case 7:
              case "end":
                return i.stop();
            }
        }, r);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "write",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i;
        return p().wrap(function(h) {
          for (; ; )
            switch (h.prev = h.next) {
              case 0:
                return h.next = 2, me(R$2.setItem(j(t), s));
              case 2:
                return n = h.sent, u = U$1(n, 2), i = u[1], h.abrupt("return", !i);
              case 6:
              case "end":
                return h.stop();
            }
        }, r);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "append",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return t = j(t), i.next = 3, this.read(t);
              case 3:
                if (n = i.sent, n) {
                  i.next = 6;
                  break;
                }
                return i.abrupt("return", false);
              case 6:
                return i.abrupt("return", this.write(t, ve$1(n, s)));
              case 7:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "remove",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                return t = j(t), c.next = 3, this.read(j(t));
              case 3:
                if (s = c.sent, n = B$1(s), n !== "empty") {
                  c.next = 7;
                  break;
                }
                return c.abrupt("return", false);
              case 7:
                return c.next = 9, me(R$2.removeItem(t));
              case 9:
                if (u = c.sent, i = U$1(u, 2), f = i[1], f) {
                  c.next = 14;
                  break;
                }
                return c.abrupt("return", !f);
              case 14:
                if (n !== "file") {
                  c.next = 16;
                  break;
                }
                return c.abrupt("return", true);
              case 16:
                return h = [], c.next = 19, this.traverse(t, function(v2) {
                  var k2 = v2.path;
                  h.push(R$2.removeItem(k2));
                });
              case 19:
                return c.next = 21, Promise.all(h);
              case 21:
                return c.abrupt("return", true);
              case 22:
              case "end":
                return c.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "stat",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n = this, u, i, f, h;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                return t = j(t), c.next = 3, this.read(t);
              case 3:
                if (u = c.sent, i = B$1(u), i !== "empty") {
                  c.next = 7;
                  break;
                }
                return c.abrupt("return", {
                  size: 0,
                  type: i
                });
              case 7:
                if (!(i === "file" || i === "link")) {
                  c.next = 9;
                  break;
                }
                return c.abrupt("return", {
                  size: u.byteLength,
                  type: i
                });
              case 9:
                if (s) {
                  c.next = 11;
                  break;
                }
                return c.abrupt("return", {
                  size: 0,
                  type: i
                });
              case 11:
                return f = 0, h = [], c.next = 15, this.traverse(t, function(v2) {
                  var k2 = v2.path;
                  h.push(m(/* @__PURE__ */ p().mark(function b() {
                    return p().wrap(function(P2) {
                      for (; ; )
                        switch (P2.prev = P2.next) {
                          case 0:
                            return P2.t0 = f, P2.next = 3, n.stat(k2, s);
                          case 3:
                            f = P2.t0 += P2.sent.size;
                          case 4:
                          case "end":
                            return P2.stop();
                        }
                    }, b);
                  }))());
                });
              case 15:
                return c.next = 17, Promise.all(h);
              case 17:
                return c.abrupt("return", {
                  size: f,
                  type: i
                });
              case 18:
              case "end":
                return c.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "exist",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return n.next = 2, this.read(j(t));
              case 2:
                return n.abrupt("return", !!n.sent);
              case 3:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "ls",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return s = [], u.next = 3, this.traverse(t, function(i) {
                  var f = i.parent, h = i.name;
                  f === t && s.push(h);
                });
              case 3:
                return u.abrupt("return", s);
              case 4:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u = arguments;
        return p().wrap(function(f) {
          for (; ; )
            switch (f.prev = f.next) {
              case 0:
                if (s = u.length > 1 && u[1] !== void 0 ? u[1] : new Uint8Array([]), n = u.length > 2 && u[2] !== void 0 ? u[2] : false, n) {
                  f.next = 7;
                  break;
                }
                return f.next = 5, this.exist(t);
              case 5:
                if (!f.sent) {
                  f.next = 7;
                  break;
                }
                return f.abrupt("return", false);
              case 7:
                return f.next = 9, this.write(t, s);
              case 9:
                return f.abrupt("return", true);
              case 10:
              case "end":
                return f.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createDir",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n = this, u;
        return p().wrap(function(f) {
          for (; ; )
            switch (f.prev = f.next) {
              case 0:
                return t = j(t), f.next = 3, this.exist(t);
              case 3:
                if (!f.sent) {
                  f.next = 11;
                  break;
                }
                if (s) {
                  f.next = 6;
                  break;
                }
                return f.abrupt("return", false);
              case 6:
                return u = [], f.next = 9, this.traverse(t, function(h) {
                  var d = h.path;
                  u.push(n.remove(d));
                });
              case 9:
                return f.next = 11, Promise.all(u);
              case 11:
                return f.next = 13, this.write(t, ne("dir"));
              case 13:
                return f.abrupt("return", true);
              case 14:
              case "end":
                return f.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "traverse",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                return c.next = 2, R$2.keys();
              case 2:
                n = c.sent, u = j(t, true), i = G(n);
                try {
                  for (i.s(); !(f = i.n()).done; )
                    h = f.value, h.startsWith(u) && s(ce$1(h));
                } catch (v2) {
                  i.e(v2);
                } finally {
                  i.f();
                }
              case 6:
              case "end":
                return c.stop();
            }
        }, r);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "getType",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return u.next = 2, this.read(t);
              case 2:
                return s = u.sent, u.abrupt("return", B$1(s));
              case 4:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }], [{
    key: "Supported",
    value: function() {
      return true;
    }
  }]);
}(), J$1 = Je(), ue = Je(true);
function Je() {
  var l2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
  return function(a, e, r) {
    var t = r.value;
    r.value = function() {
      for (var s = this, n = arguments.length, u = new Array(n), i = 0; i < n; i++)
        u[i] = arguments[i];
      var f = this.fmtPath(u[0] || ""), h = function(y) {
        return u[0] = y || f, t.apply(s, u);
      };
      if (l2) {
        var d = this._link.getSync(f);
        return h(d);
      } else {
        var c = ue$1(), v2 = c.ready, k2 = c.resolve;
        return this._link.get(f).then(function(b) {
          return h(b);
        }).then(function(b) {
          k2(b);
        }), v2;
      }
    };
  };
}
var vr = /* @__PURE__ */ function() {
  function l2(a, e) {
    R(this, l2), this.backend = a, this.syncMiddleware = e;
  }
  return H(l2, [{
    key: "get",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                if (i.t0 = s, i.t0) {
                  i.next = 5;
                  break;
                }
                return i.next = 4, this.backend.read(t);
              case 4:
                i.t0 = i.sent;
              case 5:
                return n = i.t0, i.abrupt("return", this._get(n));
              case 7:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "getSync",
    value: function(e, r) {
      var t, s = r || ((t = this.syncMiddleware) === null || t === void 0 ? void 0 : t.read(e));
      return this._get(s);
    }
  }, {
    key: "_get",
    value: function(e) {
      var r = B$1(e);
      return r === "link" ? pr(e) : "";
    }
  }]);
}(), dr = oe("zip"), we = dr.data, yr = /* @__PURE__ */ function() {
  function l2(a) {
    R(this, l2), this.disk = a;
  }
  return H(l2, [{
    key: "zip",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h, d, c, v2, k2, b, y, P2, g = arguments;
        return p().wrap(function(S2) {
          for (; ; )
            switch (S2.prev = S2.next) {
              case 0:
                s = g.length > 1 && g[1] !== void 0 ? g[1] : "compress.zip", s = this.disk.fmtPath(s), n = new Fe(), u = Le$1(), i = u.add, f = u.run, h = G(t);
                try {
                  for (h.s(); !(d = h.n()).done; )
                    c = d.value, c = this.disk.fmtPath(c), i(this.zipSingleFile(n, c));
                } catch (L2) {
                  h.e(L2);
                } finally {
                  h.f();
                }
                return S2.next = 8, f();
              case 8:
                if (v2 = S2.sent, v2.find(function(L2) {
                  return L2;
                })) {
                  S2.next = 11;
                  break;
                }
                return S2.abrupt("return", {
                  success: false,
                  info: "zip fail: no files"
                });
              case 11:
                return S2.next = 13, n.generateAsync({
                  type: "uint8array"
                });
              case 13:
                return k2 = S2.sent, b = ce$1(s), y = b.parent, S2.t0 = de, S2.t1 = [s], S2.t2 = y, S2.next = 20, this.disk.ls(y);
              case 20:
                if (S2.t3 = S2.sent, S2.t3) {
                  S2.next = 23;
                  break;
                }
                S2.t3 = [];
              case 23:
                return S2.t4 = S2.t3, P2 = (0, S2.t0)(S2.t1, S2.t2, S2.t4), S2.next = 27, this.disk.createFile(P2[s], ve$1(we, k2));
              case 27:
                return S2.abrupt("return", {
                  success: true,
                  info: P2[s]
                });
              case 28:
              case "end":
                return S2.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "zipSingleFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h, d, c, v2, k2, b, y;
        return p().wrap(function(g) {
          for (; ; )
            switch (g.prev = g.next) {
              case 0:
                return g.next = 2, this.disk.getType(s);
              case 2:
                if (n = g.sent, n !== "empty") {
                  g.next = 5;
                  break;
                }
                return g.abrupt("return", false);
              case 5:
                if (n !== "dir") {
                  g.next = 23;
                  break;
                }
                if (u = t.folder(s), u) {
                  g.next = 9;
                  break;
                }
                return g.abrupt("return", false);
              case 9:
                return g.next = 11, this.disk.ls(s);
              case 11:
                if (g.t0 = g.sent, g.t0) {
                  g.next = 14;
                  break;
                }
                g.t0 = [];
              case 14:
                i = g.t0, i = i.map(function($2) {
                  return _.join(s, $2);
                }), f = Le$1(), h = f.add, d = f.run, c = G(i);
                try {
                  for (c.s(); !(v2 = c.n()).done; )
                    k2 = v2.value, h(this.zipSingleFile(u, k2));
                } catch ($2) {
                  c.e($2);
                } finally {
                  c.f();
                }
                return g.next = 21, d();
              case 21:
                g.next = 30;
                break;
              case 23:
                return g.next = 25, this.disk.read(s);
              case 25:
                if (b = g.sent, b) {
                  g.next = 28;
                  break;
                }
                return g.abrupt("return", false);
              case 28:
                y = s.replace(t.root, ""), t.file(y, b, {
                  binary: true
                });
              case 30:
                return g.abrupt("return", true);
              case 31:
              case "end":
                return g.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "unzip",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h, d, c, v2, k2, b, y, P2, g, $2, S2, L2, T;
        return p().wrap(function(D2) {
          for (; ; )
            switch (D2.prev = D2.next) {
              case 0:
                return D2.next = 2, this.disk.read(t);
              case 2:
                if (n = D2.sent, u = this.getZipData(n), u) {
                  D2.next = 6;
                  break;
                }
                return D2.abrupt("return", []);
              case 6:
                return t = this.disk.fmtPath(t), D2.next = 9, this.unzipU8Arr(u);
              case 9:
                i = D2.sent, s = s ? this.disk.fmtPath(s) : this.disk.current, f = /* @__PURE__ */ new Set(), h = {}, d = G(i);
                try {
                  for (d.s(); !(c = d.n()).done; )
                    v2 = c.value, k2 = cr(s, v2.path), k2 && (h[v2.path] = k2, f.add(k2));
                } catch (Y2) {
                  d.e(Y2);
                } finally {
                  d.f();
                }
                return D2.t0 = de, D2.t1 = Array.from(f), D2.t2 = s, D2.next = 20, this.disk.ls(s);
              case 20:
                if (D2.t3 = D2.sent, D2.t3) {
                  D2.next = 23;
                  break;
                }
                D2.t3 = [];
              case 23:
                D2.t4 = D2.t3, b = (0, D2.t0)(D2.t1, D2.t2, D2.t4), y = [], P2 = G(i), D2.prev = 27, P2.s();
              case 29:
                if ((g = P2.n()).done) {
                  D2.next = 44;
                  break;
                }
                if ($2 = g.value, S2 = $2.path, L2 = h[$2.path], L2 && (T = b[L2], T && (S2 = S2.replace(L2, T))), !$2.isDir) {
                  D2.next = 40;
                  break;
                }
                return y.push({
                  path: S2,
                  isDir: true
                }), D2.next = 38, this.disk.createDir(S2);
              case 38:
                D2.next = 42;
                break;
              case 40:
                y.push({
                  path: S2,
                  isDir: false
                }), this.disk.createFile(S2, $2.data);
              case 42:
                D2.next = 29;
                break;
              case 44:
                D2.next = 49;
                break;
              case 46:
                D2.prev = 46, D2.t5 = D2.catch(27), P2.e(D2.t5);
              case 49:
                return D2.prev = 49, P2.f(), D2.finish(49);
              case 52:
                return D2.abrupt("return", y);
              case 53:
              case "end":
                return D2.stop();
            }
        }, r, this, [[27, 46, 49, 52]]);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "unzipU8Arr",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h, d, c, v2, k2;
        return p().wrap(function(y) {
          for (; ; )
            switch (y.prev = y.next) {
              case 0:
                return y.next = 2, Fe.loadAsync(t);
              case 2:
                n = y.sent, u = 0, i = n.files, f = Object.keys(i).length, h = [], y.t0 = p().keys(n.files);
              case 8:
                if ((y.t1 = y.t0()).done) {
                  y.next = 20;
                  break;
                }
                return d = y.t1.value, c = n.files[d], y.next = 13, c.async("uint8array");
              case 13:
                v2 = y.sent, u++, k2 = {
                  curName: c.name,
                  count: u,
                  curIndex: u,
                  curSize: f,
                  data: v2,
                  path: d,
                  isDir: c.dir
                }, s == null || s(k2), h.push(k2), y.next = 8;
                break;
              case 20:
                return y.abrupt("return", h);
              case 21:
              case "end":
                return y.stop();
            }
        }, r);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "isZip",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return u.next = 2, this.disk.read(t);
              case 2:
                if (s = u.sent, s) {
                  u.next = 5;
                  break;
                }
                return u.abrupt("return", false);
              case 5:
                return u.abrupt("return", this.isZipData(s));
              case 6:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "isZipData",
    value: function(e) {
      return Ke(e, we);
    }
  }, {
    key: "getZipData",
    value: function(e) {
      return e && this.isZipData(e) ? e.slice(we.byteLength) : null;
    }
  }]);
}(), K = /* @__PURE__ */ function(l2) {
  return l2[l2.Create = 0] = "Create", l2[l2.Remove = 1] = "Remove", l2[l2.Change = 2] = "Change", l2;
}(K || {}), je = /* @__PURE__ */ function(l2) {
  function a(e) {
    var r, t = e.watch, s = e.options, n = e.callback, u = e.path;
    return R(this, a), r = rr(this, a), t && (r.options = Object.assign({
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, s), r.watch = t, r.callback = n, r.path = u), r;
  }
  return tr(a, l2), H(a, [{
    key: "close",
    value: function() {
      var r = this.watch.watchers.indexOf(this);
      r > -1 && this.watch.watchers.splice(r, 1), this.removeAllListeners();
    }
  }, {
    key: "checkChange",
    value: function(r, t) {
      var s = this.options, n = s.recursive, u = s.encoding, i = n ? r.startsWith(this.path) : r === this.path;
      if (i) {
        var f = r.replace(this.path, ""), h = u === "buffer" ? buffer.Buffer.from(f) : buffer.Buffer.from(f, u).toString();
        this.emit("change", t, h), this.callback(t, h);
      }
    }
  }], [{
    key: "empty",
    value: function() {
      return new a({});
    }
  }]);
}(eventsExports.EventEmitter), or = /* @__PURE__ */ function() {
  function l2(a) {
    R(this, l2), this.disk = a, this.events = new eventsExports.EventEmitter(), this.watchers = [], this.fileWatchers = {};
  }
  return H(l2, [{
    key: "fireRename",
    value: function(e) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      t && this.events.emit("watch", {
        type: r ? K.Remove : K.Create,
        path: e
      }), this.watchers.forEach(function(s) {
        s.checkChange(e, "rename");
      });
    }
    // 绝对路径
  }, {
    key: "fireChange",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s = this, n, u, i, f, h = arguments;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                if (n = h.length > 1 && h[1] !== void 0 ? h[1] : true, n && this.events.emit("watch", {
                  type: K.Change,
                  path: t
                }), u = this.fileWatchers[t], i = null, !(u && u.length > 0)) {
                  c.next = 9;
                  break;
                }
                return c.next = 7, this.disk.stat(t);
              case 7:
                f = c.sent, i = function() {
                  u.forEach(/* @__PURE__ */ function() {
                    var k2 = m(/* @__PURE__ */ p().mark(function b(y) {
                      return p().wrap(function(g) {
                        for (; ; )
                          switch (g.prev = g.next) {
                            case 0:
                              return g.t0 = y, g.next = 3, s.disk.stat(t);
                            case 3:
                              return g.t1 = g.sent, g.t2 = f, g.abrupt("return", (0, g.t0)(g.t1, g.t2));
                            case 6:
                            case "end":
                              return g.stop();
                          }
                      }, b);
                    }));
                    return function(b) {
                      return k2.apply(this, arguments);
                    };
                  }());
                };
              case 9:
                return this.watchers.forEach(function(v2) {
                  v2.checkChange(t, "change");
                }), c.abrupt("return", i);
              case 11:
              case "end":
                return c.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 绝对路径
  }, {
    key: "fireChangeSync",
    value: function(e) {
      var r = this, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      t && this.events.emit("watch", {
        type: K.Change,
        path: e
      });
      var s = this.fileWatchers[e], n = null;
      if (s && s.length > 0) {
        var u = this.disk._sync.stat(e);
        n = function() {
          s.forEach(function(f) {
            return f(r.disk._sync.stat(e), u);
          });
        };
      }
      return this.watchers.forEach(function(i) {
        i.checkChange(e, "change");
      }), n;
    }
  }, {
    key: "watch",
    value: function(e, r, t) {
      if (e = this.disk.fmtPath(e), typeof r == "function" ? (t = r, r = {}) : typeof r == "string" && (r = {
        encoding: r
      }), r.persistent === false && this.watchers.find(function(n) {
        return n.path === e;
      }))
        return je.empty();
      var s = new je({
        watch: this,
        options: r,
        callback: t,
        path: e
      });
      return this.watchers.push(s), s;
    }
  }, {
    key: "watchFile",
    value: function(e, r, t) {
      e = this.disk.fmtPath(e), typeof r == "function" && (t = r, r = {});
      var s = r, n = s.persistent, u = n === void 0 ? true : n;
      u && this.fileWatchers[e] || (this.fileWatchers[e] || (this.fileWatchers[e] = []), this.fileWatchers[e].push(t));
    }
  }, {
    key: "unwatchFile",
    value: function(e, r) {
      e = this.disk.fmtPath(e);
      var t = this.fileWatchers[e];
      if (t)
        if (!r)
          delete this.fileWatchers[e];
        else {
          var s = t.indexOf(r);
          s > -1 && t.splice(s, 1), t.length === 0 && delete this.fileWatchers[e];
        }
    }
  }]);
}(), kr = /* @__PURE__ */ function() {
  function l2() {
    R(this, l2), this.fileMap = {};
  }
  return H(l2, [{
    key: "init",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s = this, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return n = [], i.next = 3, t.traverseContent(function(f, h) {
                  n.push(m(/* @__PURE__ */ p().mark(function d() {
                    var c;
                    return p().wrap(function(k2) {
                      for (; ; )
                        switch (k2.prev = k2.next) {
                          case 0:
                            return k2.next = 2, h;
                          case 2:
                            c = k2.sent, s.fileMap[f] = c || Ze().data;
                          case 4:
                          case "end":
                            return k2.stop();
                        }
                    }, d);
                  }))());
                });
              case 3:
                return i.next = 5, Promise.all(n);
              case 5:
              case "end":
                return i.stop();
            }
        }, r);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "read",
    value: function(e) {
      var r = this.fileMap[e], t = B$1(r);
      return t === "empty" || t === "dir" ? null : r;
    }
  }, {
    key: "pureRead",
    value: function(e) {
      return this.fileMap[e];
    }
  }, {
    key: "write",
    value: function(e, r) {
      return this.fileMap[e] = r, true;
    }
  }, {
    key: "append",
    value: function(e, r) {
      if (e in this.fileMap)
        return false;
      var t = this.read(e);
      if (!t)
        throw new Error("file not found");
      return this.write(e, ve$1(t, r));
    }
  }, {
    key: "remove",
    value: function(e, r) {
      var t = this, s = this.getType(e);
      return s === "empty" || !(e in this.fileMap) ? false : (this._removeSingle(e, r), s === "file" || this.traverse(e, function(n) {
        var u = n.path;
        t._removeSingle(u, r);
      }), true);
    }
  }, {
    key: "_removeSingle",
    value: function(e, r) {
      delete this.fileMap[e], r == null || r(e);
    }
  }, {
    key: "stat",
    value: function(e, r) {
      var t = this, s = this.fileMap[e], n = B$1(s);
      if (n === "empty")
        return {
          size: 0,
          type: n
        };
      if (n === "file" || n === "link")
        return {
          size: s.byteLength,
          type: n
        };
      if (!r)
        return {
          size: 0,
          type: n
        };
      var u = 0;
      return this.traverse(e, function(i) {
        var f = i.path, h = t.fileMap[f], d = B$1(h);
        d === "file" && (u += h.byteLength);
      }), {
        size: u,
        type: n
      };
    }
  }, {
    key: "exist",
    value: function(e) {
      return e in this.fileMap;
    }
  }, {
    key: "ls",
    value: function(e) {
      var r = [];
      return this.traverse(e, function(t) {
        var s = t.parent, n = t.name;
        s === e && r.push(n);
      }), r;
    }
  }, {
    key: "createFile",
    value: function(e) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Uint8Array([]), t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      return !t && this.exist(e) ? false : (this.write(e, r), true);
    }
  }, {
    key: "createDir",
    value: function(e, r) {
      var t = this;
      if (this.exist(e)) {
        if (!r)
          return false;
        this.traverse(e, function(s) {
          var n = s.path;
          t.remove(n);
        });
      }
      return this.write(e, ne("dir")), true;
    }
  }, {
    key: "getType",
    value: function(e) {
      var r = this.fileMap[e];
      return B$1(r);
    }
  }, {
    key: "traverse",
    value: function(e, r) {
      for (var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, s = Object.keys(this.fileMap), n = j(e, !t), u = 0, i = s; u < i.length; u++) {
        var f = i[u];
        f.startsWith(n) && r(ce$1(f));
      }
    }
  }, {
    key: "traverseContent",
    value: function(e) {
      var r = this, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      this.traverse(t, function(s) {
        var n = s.path;
        e(n, r.read(n));
      });
    }
  }]);
}(), mr = Object.defineProperty, wr = Object.getOwnPropertyDescriptor, le = function(a, e, r, t) {
  for (var s = wr(e, r), n = a.length - 1, u; n >= 0; n--)
    (u = a[n]) && (s = u(e, r, s) || s);
  return s && mr(e, r, s), s;
}, x = /* @__PURE__ */ function() {
  function l2(a) {
    R(this, l2), this.syncMiddleware = new kr(), this.disk = a;
  }
  return H(l2, [{
    key: "init",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        return p().wrap(function(s) {
          for (; ; )
            switch (s.prev = s.next) {
              case 0:
                return s.next = 2, this.syncMiddleware.init(this.backend);
              case 2:
              case "end":
                return s.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "fmtPath",
    value: function(e) {
      return this.disk.fmtPath(e);
    }
  }, {
    key: "_link",
    get: function() {
      return this.disk._link;
    }
  }, {
    key: "_watch",
    get: function() {
      return this.disk._watch;
    }
  }, {
    key: "backend",
    get: function() {
      return this.disk.backend;
    }
  }, {
    key: "size",
    value: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "/";
      return this.syncMiddleware.stat(this.fmtPath(e)).size;
    }
  }, {
    key: "cd",
    value: function(e) {
      return e = this.fmtPath(e), this.isDir(e) ? (this.disk.current = e, true) : false;
    }
  }, {
    key: "isDir",
    value: function(e) {
      return e = this.fmtPath(e), e === "/" || this.getType(e) === "dir";
    }
  }, {
    key: "getType",
    value: function(e) {
      return this.syncMiddleware.getType(this.fmtPath(e));
    }
  }, {
    key: "pwd",
    value: function() {
      return this.disk.current;
    }
  }, {
    key: "copy",
    value: function(e) {
      return this.disk.copy(e), true;
    }
  }, {
    key: "cut",
    value: function(e) {
      return this.disk.cut(e), true;
    }
  }, {
    key: "move",
    value: function(e, r, t) {
      var s = this.fmtPath(r), n = this.fmtPath(e), u = Z$1(s);
      return this.pasteBase(u, {
        paths: [n],
        active: true,
        isCut: true
      }, pe({}, n, s), function(i) {
        t == null || t(i[n]);
      });
    }
  }, {
    key: "rename",
    value: function(e, r, t) {
      e = this.fmtPath(e);
      var s = Z$1(e), n = _.join(s, r);
      return this.pasteBase(s, {
        paths: [e],
        active: true,
        isCut: true
      }, pe({}, e, n), function(u) {
        t == null || t(u[e]);
      });
    }
  }, {
    key: "paste",
    value: function(e) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0, s = this.pasteBase(e, this.disk.clipboard, r, t);
      return !s && this.disk.clipboard.isCut && (this.disk.clipboard = {
        paths: [],
        active: false,
        isCut: false
      }), s;
    }
  }, {
    key: "pasteBase",
    value: function(e, r) {
      var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s = arguments.length > 3 ? arguments[3] : void 0;
      if (!r.active)
        return "No Copy Files";
      var n = this.ls(e), u = n || [], i = r.isCut, f = r.paths, h = de(f, this.fmtPath(e), u, t);
      s == null || s(h);
      var d = [];
      for (var c in h) {
        var v2 = c, k2 = h[v2];
        this.copySingle(v2, k2) ? i && this.remove(v2) : d.push(v2);
      }
      return d.length > 0 ? "Copy Failed: ".concat(d.join(", ")) : "";
    }
  }, {
    key: "ls",
    value: function() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return e = this.fmtPath(e), this.isDir(e) ? this.syncMiddleware.ls(e) : null;
    }
  }, {
    key: "remove",
    value: function(e) {
      var r = this;
      return e = this.fmtPath(e), this.backend.remove(e), this.syncMiddleware.remove(e, function(t) {
        r._watch.fireRename(t, true);
      });
    }
  }, {
    key: "clear",
    value: function() {
      var e = this, r = this.ls("/");
      !r || r.length === 0 || (r.forEach(function(t) {
        e.remove(_.join("/", t));
      }), this.cd("/"));
    }
  }, {
    key: "copySingle",
    value: function(e, r) {
      var t = this, s = this.read(e), n = "empty";
      if (s ? n = B$1(s) : n = this.isDir(e) ? "dir" : "empty", n === "empty")
        return false;
      if (n === "file" || n === "link")
        return this.createFile(r, s, {
          ensure: true
        });
      var u = [], i = true, f = function(d, c, v2) {
        var k2 = {
          ensure: true
        }, b = function() {
          return Promise.resolve(true);
        }, y = t._create(d, v2 || void 0, k2, c === "dir", function(P2) {
          b = P2;
        });
        if (t.createFile(d, v2 || void 0, k2), !y)
          throw i = false, new Error("create fail: ".concat(d));
        return u.push(b), y;
      };
      return f(r, "dir"), this.syncMiddleware.traverseContent(function(h, d) {
        var c = h.replace(e, r);
        f(c, d ? "file" : "dir", d);
      }, e), be(u), i;
    }
  }, {
    key: "traverseContent",
    value: function(e, r) {
      return this.syncMiddleware.traverseContent(function(t, s) {
        r(t, s, lr(t));
      }, e);
    }
  }, {
    key: "traverse",
    value: function(e, r) {
      return this.syncMiddleware.traverse(e, r);
    }
  }, {
    key: "read",
    value: function(e) {
      return this.syncMiddleware.read(e);
    }
  }, {
    key: "readText",
    value: function(e) {
      var r = this.syncMiddleware.read(e);
      return r ? we$1(r) : "";
    }
  }, {
    key: "write",
    value: function(e, r) {
      e = this.fmtPath(e);
      var t = this.syncMiddleware.pureRead(e);
      if (ye(r, t))
        return true;
      if (!this.exist(e))
        return this.createFile(e, r);
      var s = this._watch.fireChangeSync(e), n = this.syncMiddleware.write(e, r);
      return n ? (this.backend.write(e, r), s == null || s(), true) : false;
    }
  }, {
    key: "append",
    value: function(e, r) {
      if (e = this.fmtPath(e), !this.exist(e))
        return this.createFile(e, r);
      var t = this._watch.fireChangeSync(e), s = this.syncMiddleware.append(e, r);
      return s ? (this.backend.append(e, r), t == null || t(), true) : false;
    }
  }, {
    key: "exist",
    value: function(e) {
      return e = this.fmtPath(e), e === "/" ? true : this.syncMiddleware.exist(e);
    }
    // @linkSync
  }, {
    key: "stat",
    value: function(e) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return this.disk._transStat(this.syncMiddleware.stat(this.fmtPath(e), r));
    }
  }, {
    key: "createFile",
    value: function(e, r) {
      var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this._create(e, r, t);
    }
  }, {
    key: "createDir",
    value: function(e) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this._create(e, void 0, r, true);
    }
  }, {
    key: "createLink",
    value: function(e, r) {
      var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.createFile(e, ne("link", r), t);
    }
  }, {
    key: "_create",
    value: function(e, r) {
      var t = this, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = s.overwrite, u = s.ensure, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false, f = arguments.length > 4 ? arguments[4] : void 0;
      e = this.fmtPath(e);
      var h = Z$1(e);
      if (!u && !this.exist(h))
        return false;
      var d = u ? this.ensureParentPath(e) : null, c = i ? this.syncMiddleware.createDir(e, n) : (
        // @ts-ignore
        this.syncMiddleware.createFile(e, r, n)
      );
      if (!c)
        return false;
      this._watch.fireRename(e);
      var v2 = /* @__PURE__ */ function() {
        var k2 = m(/* @__PURE__ */ p().mark(function b() {
          return p().wrap(function(P2) {
            for (; ; )
              switch (P2.prev = P2.next) {
                case 0:
                  if (!u) {
                    P2.next = 3;
                    break;
                  }
                  return P2.next = 3, d;
                case 3:
                  return P2.abrupt("return", i ? t.backend.createDir(e, n) : t.backend.createFile(e, r, n));
                case 4:
                case "end":
                  return P2.stop();
              }
          }, b);
        }));
        return function() {
          return k2.apply(this, arguments);
        };
      }();
      return f ? f(v2) : v2(), true;
    }
  }, {
    key: "ensureParentPath",
    value: function(e) {
      return this._ensureParentPath(e), this.disk._ensureParentPath(e);
    }
  }, {
    key: "_ensureParentPath",
    value: function(e) {
      e = Z$1(e), !this.exist(e) && (this._ensureParentPath(e), this._create(e, void 0, {}, true, function() {
      }));
    }
  }]);
}();
le([ue], x.prototype, "ls");
le([ue], x.prototype, "read");
le([ue], x.prototype, "readText");
le([ue], x.prototype, "write");
le([ue], x.prototype, "append");
var Oe = 500, ce = function() {
  var l2 = "webos_fs_update_info", a = R$2.createInstance({
    name: "sync-manager",
    driver: R$2.INDEXEDDB
  }), e = Math.random().toString(16).substring(2), r = function(s) {
    return a.setItem(l2, s);
  };
  return {
    id: e,
    writeData: function(s) {
      return m(/* @__PURE__ */ p().mark(function n() {
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return i.next = 2, r(s);
              case 2:
              case "end":
                return i.stop();
            }
        }, n);
      }))();
    },
    writeChanges: function(s) {
      var n = this;
      return m(/* @__PURE__ */ p().mark(function u() {
        var i, f, h;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                return c.next = 2, n.read();
              case 2:
                return i = c.sent, f = {
                  time: Date.now(),
                  id: e,
                  changes: s
                }, i.length === 0 ? i.push(f) : (h = i.findIndex(function(v2) {
                  return v2.time > f.time;
                }), h === -1 ? i.push(f) : i.splice(h, 0, f)), c.next = 7, r(i);
              case 7:
              case "end":
                return c.stop();
            }
        }, u);
      }))();
    },
    read: function() {
      return m(/* @__PURE__ */ p().mark(function s() {
        var n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return i.next = 2, a.getItem(l2);
              case 2:
                if (n = i.sent, Array.isArray(n)) {
                  i.next = 5;
                  break;
                }
                return i.abrupt("return", []);
              case 5:
                return i.abrupt("return", n);
              case 6:
              case "end":
                return i.stop();
            }
        }, s);
      }))();
    }
  };
}(), gr = /* @__PURE__ */ function() {
  function l2(a) {
    R(this, l2), this.tempChange = {}, this.lastOprateId = "", this.disk = a;
  }
  return H(l2, [{
    key: "init",
    value: function() {
      var e = this;
      this.timer = setInterval(/* @__PURE__ */ m(/* @__PURE__ */ p().mark(function t() {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return n.next = 2, e.checkUpdate();
              case 2:
                return n.next = 4, e.checkWriteChange();
              case 4:
              case "end":
                return n.stop();
            }
        }, t);
      })), Oe);
      var r = function(s) {
        var n = s.path, u = s.type;
        e.tempChange[n] = u;
      };
      this.disk._watch.events.on("watch", r), this.offWatch = function() {
        e.disk._watch.events.off("watch", r);
      };
    }
  }, {
    key: "sync",
    get: function() {
      var e;
      return (e = this.disk._sync) === null || e === void 0 ? void 0 : e.syncMiddleware;
    }
    // 检查更新的文件
  }, {
    key: "checkUpdate",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        var t, s, n, u, i, f, h, d;
        return p().wrap(function(v2) {
          for (; ; )
            switch (v2.prev = v2.next) {
              case 0:
                return v2.next = 2, ce.read();
              case 2:
                if (t = v2.sent, t.length !== 0) {
                  v2.next = 5;
                  break;
                }
                return v2.abrupt("return");
              case 5:
                s = [], n = Date.now(), u = function(b) {
                  return n - b > Oe * 2;
                }, i = {}, f = 0;
              case 10:
                if (!(f < t.length)) {
                  v2.next = 21;
                  break;
                }
                if (h = t[f], !u(h.time)) {
                  v2.next = 15;
                  break;
                }
                return s.push(f), v2.abrupt("continue", 18);
              case 15:
                if (h.id !== ce.id) {
                  v2.next = 17;
                  break;
                }
                return v2.abrupt("continue", 18);
              case 17:
                Object.assign(i, h.changes);
              case 18:
                f++, v2.next = 10;
                break;
              case 21:
                if (!s.length) {
                  v2.next = 25;
                  break;
                }
                for (d = s.length - 1; d >= 0; d--)
                  t.splice(s[d], 1);
                return v2.next = 25, ce.writeData(t);
              case 25:
                this.useChanges(i);
              case 26:
              case "end":
                return v2.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 同步syncMiddleware的内容
  }, {
    key: "writeFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                if (this.disk.enableSync) {
                  i.next = 2;
                  break;
                }
                return i.abrupt("return", true);
              case 2:
                return i.next = 4, this.disk.read(t);
              case 4:
                if (s = i.sent, !s) {
                  i.next = 11;
                  break;
                }
                if (n = this.sync.pureRead(t), !ye(s, n)) {
                  i.next = 9;
                  break;
                }
                return i.abrupt("return", false);
              case 9:
                return this.sync.write(t, s), i.abrupt("return", true);
              case 11:
                return i.abrupt("return", false);
              case 12:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "useChanges",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i, f, h;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                if (Object.keys(t).length !== 0) {
                  c.next = 2;
                  break;
                }
                return c.abrupt("return");
              case 2:
                s = Object.keys(t).sort(function(v2, k2) {
                  return v2.length - k2.length;
                }), n = G(s), c.prev = 4, n.s();
              case 6:
                if ((u = n.n()).done) {
                  c.next = 36;
                  break;
                }
                i = u.value, f = t[i], c.t0 = f, c.next = c.t0 === K.Change ? 12 : c.t0 === K.Remove ? 20 : c.t0 === K.Create ? 26 : 33;
                break;
              case 12:
                return c.next = 14, this.disk.exist(i);
              case 14:
                if (!c.sent) {
                  c.next = 19;
                  break;
                }
                return c.next = 17, this.writeFile(i);
              case 17:
                if (!c.sent) {
                  c.next = 19;
                  break;
                }
                this.disk._watch.fireChangeSync(i, false);
              case 19:
                return c.abrupt("break", 34);
              case 20:
                return c.next = 22, this.disk.exist(i);
              case 22:
                if (!c.sent) {
                  c.next = 25;
                  break;
                }
                (h = this.sync) === null || h === void 0 || h.remove(i), this.disk._watch.fireRename(i, true, false);
              case 25:
                return c.abrupt("break", 34);
              case 26:
                return c.next = 28, this.disk.exist(i);
              case 28:
                if (c.sent) {
                  c.next = 32;
                  break;
                }
                return c.next = 31, this.writeFile(i);
              case 31:
                this.disk._watch.fireRename(i, false, false);
              case 32:
                return c.abrupt("break", 34);
              case 33:
                return c.abrupt("break", 34);
              case 34:
                c.next = 6;
                break;
              case 36:
                c.next = 41;
                break;
              case 38:
                c.prev = 38, c.t1 = c.catch(4), n.e(c.t1);
              case 41:
                return c.prev = 41, n.f(), c.finish(41);
              case 44:
              case "end":
                return c.stop();
            }
        }, r, this, [[4, 38, 41, 44]]);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "checkWriteChange",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        return p().wrap(function(s) {
          for (; ; )
            switch (s.prev = s.next) {
              case 0:
                if (Object.keys(this.tempChange).length !== 0) {
                  s.next = 2;
                  break;
                }
                return s.abrupt("return");
              case 2:
                return s.next = 4, ce.writeChanges(this.tempChange);
              case 4:
                this.tempChange = {};
              case 5:
              case "end":
                return s.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "clear",
    value: function() {
      clearInterval(this.timer), this.offWatch();
    }
  }]);
}(), br = Object.defineProperty, Pr = Object.getOwnPropertyDescriptor, V = function(a, e, r, t) {
  for (var s = Pr(e, r), n = a.length - 1, u; n >= 0; n--)
    (u = a[n]) && (s = u(e, r, s) || s);
  return s && br(e, r, s), s;
}, N = /* @__PURE__ */ function() {
  function l2() {
    var a, e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = e.enableSync, t = r === void 0 ? false : r;
    if (R(this, l2), this.current = "/", this.clipboard = {
      paths: [],
      isCut: false,
      active: false
    }, l2.instance)
      return l2.instance._initSyncAlone(t), l2.instance;
    if (l2.instance = this, this.enableSync = t, Me.Supported())
      this.backend = new Me();
    else if (Le.Supported())
      this.backend = new Le();
    else
      throw new Error("No supported storage backend");
    this.enableSync && (this._sync = new x(this)), this._link = new vr(this.backend, (a = this._sync) === null || a === void 0 ? void 0 : a.syncMiddleware), this._zip = new yr(this), this._watch = new or(this), this._update = new gr(this), this._update.init(), this.ready = this.init();
  }
  return H(l2, [{
    key: "sync",
    get: function() {
      return this._sync;
    }
  }, {
    key: "initSync",
    value: function() {
      return this._initSyncAlone(true);
    }
  }, {
    key: "_initSyncAlone",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                if (!(t && !this.enableSync)) {
                  n.next = 6;
                  break;
                }
                return this.enableSync = t, this._sync = new x(this), this.ready = this._sync.init(), n.next = 6, this.ready;
              case 6:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "init",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        var t;
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return n.next = 2, this.backend.init();
              case 2:
                return n.next = 4, (t = this._sync) === null || t === void 0 ? void 0 : t.init();
              case 4:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "fmtPath",
    value: function(e) {
      return e = e.trim(), e[0] === "/" ? j(e) : _.join(this.current, j(e));
    }
  }, {
    key: "size",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        var t, s = arguments;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return t = s.length > 0 && s[0] !== void 0 ? s[0] : "/", u.next = 3, this.backend.stat(this.fmtPath(t));
              case 3:
                return u.abrupt("return", u.sent.size);
              case 4:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // 以下为磁盘方法
  }, {
    key: "cd",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return t = this.fmtPath(t), n.next = 3, this.isDir(t);
              case 3:
                if (n.sent) {
                  n.next = 5;
                  break;
                }
                return n.abrupt("return", false);
              case 5:
                return this.current = t, n.abrupt("return", true);
              case 7:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "isDir",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                if (t = this.fmtPath(t), n.t0 = t === "/", n.t0) {
                  n.next = 7;
                  break;
                }
                return n.next = 5, this.getType(t);
              case 5:
                n.t1 = n.sent, n.t0 = n.t1 === "dir";
              case 7:
                return n.abrupt("return", n.t0);
              case 8:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "getType",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return t = this.fmtPath(t), n.abrupt("return", this.backend.getType(t));
              case 2:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "pwd",
    value: function() {
      return this.current;
    }
  }, {
    key: "copy",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return n.abrupt("return", this._addToClipboard(t));
              case 1:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "cut",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return n.abrupt("return", this._addToClipboard(t, true));
              case 1:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_addToClipboard",
    value: function(e) {
      var r = this, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return typeof e == "string" && (e = [e]), this.clipboard = {
        paths: e.map(function(s) {
          return r.fmtPath(s);
        }),
        active: true,
        isCut: t
      }, true;
    }
  }, {
    key: "move",
    value: function(e, r, t) {
      var s = this.fmtPath(r), n = this.fmtPath(e), u = Z$1(s);
      return this.pasteBase(u, {
        paths: [n],
        active: true,
        isCut: true
      }, pe({}, n, s), function(i) {
        t == null || t(i[n]);
      });
    }
  }, {
    key: "rename",
    value: function(e, r, t) {
      e = this.fmtPath(e);
      var s = Z$1(e), n = _.join(s, r);
      return this.pasteBase(s, {
        paths: [e],
        active: true,
        isCut: true
      }, pe({}, e, n), function(u) {
        t == null || t(u[e]);
      });
    }
  }, {
    key: "paste",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n, u, i = arguments;
        return p().wrap(function(h) {
          for (; ; )
            switch (h.prev = h.next) {
              case 0:
                return s = i.length > 1 && i[1] !== void 0 ? i[1] : {}, n = i.length > 2 ? i[2] : void 0, h.next = 4, this.pasteBase(t, this.clipboard, s, n);
              case 4:
                return u = h.sent, !u && this.clipboard.isCut && (this.clipboard = {
                  paths: [],
                  active: false,
                  isCut: false
                }), h.abrupt("return", u);
              case 7:
              case "end":
                return h.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "pasteBase",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n = this, u, i, f, h, d, c, v2, k2, b, y, P2, g = arguments;
        return p().wrap(function(S2) {
          for (; ; )
            switch (S2.prev = S2.next) {
              case 0:
                if (u = g.length > 2 && g[2] !== void 0 ? g[2] : {}, i = g.length > 3 ? g[3] : void 0, s.active) {
                  S2.next = 4;
                  break;
                }
                return S2.abrupt("return", "No Copy Files");
              case 4:
                return S2.next = 6, this.ls(t);
              case 6:
                f = S2.sent, h = f || [], d = s.isCut, c = s.paths, v2 = de(c, this.fmtPath(t), h, u), i == null || i(v2), k2 = [], b = [], y = /* @__PURE__ */ p().mark(function L2(T) {
                  return p().wrap(function(D2) {
                    for (; ; )
                      switch (D2.prev = D2.next) {
                        case 0:
                          b.push(m(/* @__PURE__ */ p().mark(function Y2() {
                            var X2, ie;
                            return p().wrap(function(O2) {
                              for (; ; )
                                switch (O2.prev = O2.next) {
                                  case 0:
                                    return X2 = T, ie = v2[X2], O2.next = 4, n.copySingle(X2, ie);
                                  case 4:
                                    if (O2.sent) {
                                      O2.next = 8;
                                      break;
                                    }
                                    k2.push(X2), O2.next = 11;
                                    break;
                                  case 8:
                                    if (!d) {
                                      O2.next = 11;
                                      break;
                                    }
                                    return O2.next = 11, n.remove(X2);
                                  case 11:
                                  case "end":
                                    return O2.stop();
                                }
                            }, Y2);
                          }))());
                        case 1:
                        case "end":
                          return D2.stop();
                      }
                  }, L2);
                }), S2.t0 = p().keys(v2);
              case 15:
                if ((S2.t1 = S2.t0()).done) {
                  S2.next = 20;
                  break;
                }
                return P2 = S2.t1.value, S2.delegateYield(y(P2), "t2", 18);
              case 18:
                S2.next = 15;
                break;
              case 20:
                return S2.next = 22, Promise.all(b);
              case 22:
                if (!(k2.length > 0)) {
                  S2.next = 24;
                  break;
                }
                return S2.abrupt("return", "Copy Failed: ".concat(k2.join(", ")));
              case 24:
                return S2.abrupt("return", "");
              case 25:
              case "end":
                return S2.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "copySingle",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n = this, u, i, f, h;
        return p().wrap(function(c) {
          for (; ; )
            switch (c.prev = c.next) {
              case 0:
                return c.next = 2, this.read(t);
              case 2:
                if (u = c.sent, i = "empty", !u) {
                  c.next = 8;
                  break;
                }
                i = B$1(u), c.next = 16;
                break;
              case 8:
                return c.next = 10, this.isDir(t);
              case 10:
                if (!c.sent) {
                  c.next = 14;
                  break;
                }
                c.t0 = "dir", c.next = 15;
                break;
              case 14:
                c.t0 = "empty";
              case 15:
                i = c.t0;
              case 16:
                if (i !== "empty") {
                  c.next = 18;
                  break;
                }
                return c.abrupt("return", false);
              case 18:
                if (!(i === "file" || i === "link")) {
                  c.next = 22;
                  break;
                }
                return c.next = 21, this.createFile(s, u, {
                  ensure: true
                });
              case 21:
                return c.abrupt("return", c.sent);
              case 22:
                return f = true, h = [function() {
                  return n.createDir(s);
                }], c.next = 26, this.backend.traverseContent(function(v2, k2) {
                  h.push(/* @__PURE__ */ m(/* @__PURE__ */ p().mark(function b() {
                    var y, P2;
                    return p().wrap(function($2) {
                      for (; ; )
                        switch ($2.prev = $2.next) {
                          case 0:
                            return $2.next = 2, k2;
                          case 2:
                            if (y = $2.sent, P2 = v2.replace(t, s), !y) {
                              $2.next = 11;
                              break;
                            }
                            return $2.next = 7, n.createFile(P2, y);
                          case 7:
                            if ($2.sent) {
                              $2.next = 9;
                              break;
                            }
                            f = false;
                          case 9:
                            $2.next = 15;
                            break;
                          case 11:
                            return $2.next = 13, n.createDir(P2);
                          case 13:
                            if ($2.sent) {
                              $2.next = 15;
                              break;
                            }
                            f = false;
                          case 15:
                          case "end":
                            return $2.stop();
                        }
                    }, b);
                  })));
                }, t);
              case 26:
                return c.next = 28, be(h);
              case 28:
                return c.abrupt("return", f);
              case 29:
              case "end":
                return c.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "traverseContent",
    value: function(e, r) {
      return this.backend.traverseContent(r, e);
    }
  }, {
    key: "traverse",
    value: function(e, r) {
      return this.backend.traverseContent(function(t, s, n) {
        r({
          path: t,
          parent: Z$1(t),
          name: n
        });
      }, e, false);
    }
  }, {
    key: "readText",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return u.next = 2, this.backend.read(t);
              case 2:
                if (s = u.sent, s) {
                  u.next = 5;
                  break;
                }
                return u.abrupt("return", "");
              case 5:
                return u.abrupt("return", we$1(s));
              case 6:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "read",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return n.abrupt("return", this.backend.read(t));
              case 1:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "write",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f;
        return p().wrap(function(d) {
          for (; ; )
            switch (d.prev = d.next) {
              case 0:
                if (t = this.fmtPath(t), !this.enableSync) {
                  d.next = 5;
                  break;
                }
                d.t0 = this._sync.syncMiddleware.pureRead(t), d.next = 8;
                break;
              case 5:
                return d.next = 7, this.backend.read(t);
              case 7:
                d.t0 = d.sent;
              case 8:
                if (u = d.t0, !ye(s, u)) {
                  d.next = 11;
                  break;
                }
                return d.abrupt("return", true);
              case 11:
                return d.next = 13, this.exist(t);
              case 13:
                if (d.sent) {
                  d.next = 15;
                  break;
                }
                return d.abrupt("return", this.createFile(t, s));
              case 15:
                return d.next = 17, this._watch.fireChange(t);
              case 17:
                return i = d.sent, d.next = 20, this.backend.write(t, s);
              case 20:
                if (f = d.sent, f) {
                  d.next = 23;
                  break;
                }
                return d.abrupt("return", false);
              case 23:
                return (n = this._sync) === null || n === void 0 || n.syncMiddleware.write(t, s), i == null || i(), d.abrupt("return", true);
              case 26:
              case "end":
                return d.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "append",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i;
        return p().wrap(function(h) {
          for (; ; )
            switch (h.prev = h.next) {
              case 0:
                return t = this.fmtPath(t), h.next = 3, this.exist(t);
              case 3:
                if (h.sent) {
                  h.next = 5;
                  break;
                }
                return h.abrupt("return", this.createFile(t, s));
              case 5:
                return h.next = 7, this._watch.fireChange(t);
              case 7:
                return u = h.sent, h.next = 10, this.backend.append(t, s);
              case 10:
                if (i = h.sent, i) {
                  h.next = 13;
                  break;
                }
                return h.abrupt("return", false);
              case 13:
                return (n = this._sync) === null || n === void 0 || n.syncMiddleware.append(t, s), u == null || u(), h.abrupt("return", true);
              case 16:
              case "end":
                return h.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "remove",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s = this, n;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return t = this.fmtPath(t), i.next = 3, this.backend.remove(t);
              case 3:
                if (n = i.sent, n) {
                  i.next = 6;
                  break;
                }
                return i.abrupt("return", n);
              case 6:
                return this.enableSync ? this._sync.syncMiddleware.remove(t, function(f) {
                  s._watch.fireRename(f, true);
                }) : this._watch.fireRename(t, true), i.abrupt("return", true);
              case 8:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
    // @link
  }, {
    key: "stat",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n = arguments;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return s = n.length > 1 && n[1] !== void 0 ? n[1] : true, i.t0 = this, i.next = 4, this.backend.stat(this.fmtPath(t), s);
              case 4:
                return i.t1 = i.sent, i.abrupt("return", i.t0._transStat.call(i.t0, i.t1));
              case 6:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_transStat",
    value: function(e) {
      var r = e.size, t = e.type;
      return {
        size: r,
        type: t,
        isDirectory: function() {
          return t === "dir";
        },
        isFile: function() {
          return t === "file";
        }
      };
    }
  }, {
    key: "exist",
    value: function(e) {
      return e = this.fmtPath(e), e === "/" ? Promise.resolve(true) : this.backend.exist(e);
    }
  }, {
    key: "ls",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        var t, s = arguments;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                if (t = s.length > 0 && s[0] !== void 0 ? s[0] : "", t = this.fmtPath(t), this.isDir(t)) {
                  u.next = 4;
                  break;
                }
                return u.abrupt("return", null);
              case 4:
                return u.next = 6, this.backend.ls(t);
              case 6:
                return u.abrupt("return", u.sent);
              case 7:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createFile",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u = arguments;
        return p().wrap(function(f) {
          for (; ; )
            switch (f.prev = f.next) {
              case 0:
                return n = u.length > 2 && u[2] !== void 0 ? u[2] : {}, f.abrupt("return", this._create(t, s, n, false));
              case 2:
              case "end":
                return f.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createDir",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s, n = arguments;
        return p().wrap(function(i) {
          for (; ; )
            switch (i.prev = i.next) {
              case 0:
                return s = n.length > 1 && n[1] !== void 0 ? n[1] : {}, i.abrupt("return", this._create(t, void 0, s, true));
              case 2:
              case "end":
                return i.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_create",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t, s) {
        var n, u, i, f, h, d, c = arguments;
        return p().wrap(function(k2) {
          for (; ; )
            switch (k2.prev = k2.next) {
              case 0:
                if (n = c.length > 2 && c[2] !== void 0 ? c[2] : {}, u = n.overwrite, i = n.ensure, f = c.length > 3 && c[3] !== void 0 ? c[3] : false, t = this.fmtPath(t), h = Z$1(t), k2.t0 = !i, !k2.t0) {
                  k2.next = 9;
                  break;
                }
                return k2.next = 8, this.exist(h);
              case 8:
                k2.t0 = !k2.sent;
              case 9:
                if (!k2.t0) {
                  k2.next = 11;
                  break;
                }
                return k2.abrupt("return", false);
              case 11:
                if (!i) {
                  k2.next = 14;
                  break;
                }
                return k2.next = 14, this.ensureParentPath(t);
              case 14:
                return k2.next = 16, f ? this.backend.createDir(t, u) : this.backend.createFile(t, s, u);
              case 16:
                if (d = k2.sent, d) {
                  k2.next = 19;
                  break;
                }
                return k2.abrupt("return", false);
              case 19:
                return this._watch.fireRename(t), this.enableSync && (f ? this._sync.syncMiddleware.createDir(t, u) : (
                  // @ts-ignore
                  this._sync.syncMiddleware.createFile(t, s, u)
                )), k2.abrupt("return", d);
              case 22:
              case "end":
                return k2.stop();
            }
        }, r, this);
      }));
      function e(r, t) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createLink",
    value: function(e, r) {
      var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.createFile(e, ne("link", r), t);
    }
  }, {
    key: "zip",
    value: function() {
      var e;
      return (e = this._zip).zip.apply(e, arguments);
    }
  }, {
    key: "unzip",
    value: function() {
      var e;
      return (e = this._zip).unzip.apply(e, arguments);
    }
  }, {
    key: "isZip",
    value: function() {
      var e;
      return (e = this._zip).isZip.apply(e, arguments);
    }
  }, {
    key: "watch",
    value: function() {
      var e;
      return (e = this._watch).watch.apply(e, arguments);
    }
  }, {
    key: "watchFile",
    value: function() {
      var e;
      return (e = this._watch).watchFile.apply(e, arguments);
    }
  }, {
    key: "unwatchFile",
    value: function() {
      var e;
      return (e = this._watch).unwatchFile.apply(e, arguments);
    }
  }, {
    key: "clear",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r() {
        var t = this, s;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return u.next = 2, this.ls("/");
              case 2:
                if (s = u.sent, !(!s || s.length === 0)) {
                  u.next = 5;
                  break;
                }
                return u.abrupt("return");
              case 5:
                return u.next = 7, Promise.all(s.map(function(i) {
                  return t.remove(_.join("/", i));
                }));
              case 7:
                return u.next = 9, this.cd("/");
              case 9:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e() {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "ensureParentPath",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        var s;
        return p().wrap(function(u) {
          for (; ; )
            switch (u.prev = u.next) {
              case 0:
                return (s = this._sync) === null || s === void 0 || s._ensureParentPath(t), u.abrupt("return", this._ensureParentPath(t));
              case 2:
              case "end":
                return u.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "_ensureParentPath",
    value: function() {
      var a = m(/* @__PURE__ */ p().mark(function r(t) {
        return p().wrap(function(n) {
          for (; ; )
            switch (n.prev = n.next) {
              case 0:
                return t = Z$1(t), n.next = 3, this.exist(t);
              case 3:
                if (!n.sent) {
                  n.next = 5;
                  break;
                }
                return n.abrupt("return");
              case 5:
                return n.next = 7, this.ensureParentPath(t);
              case 7:
                return n.next = 9, this._create(t, void 0, {}, true);
              case 9:
              case "end":
                return n.stop();
            }
        }, r, this);
      }));
      function e(r) {
        return a.apply(this, arguments);
      }
      return e;
    }()
  }, {
    key: "createFileContent",
    value: function(e) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "file";
      return ne(r, e);
    }
  }], [{
    key: "initSync",
    value: function() {
      if (!l2.instance) {
        var e = new l2({
          enableSync: true
        });
        return e.ready;
      }
      return l2.instance.initSync();
    }
  }]);
}();
V([J$1], N.prototype, "readText");
V([J$1], N.prototype, "read");
V([J$1], N.prototype, "write");
V([J$1], N.prototype, "append");
V([J$1], N.prototype, "ls");
V([J$1], N.prototype, "watch");
V([J$1], N.prototype, "watchFile");
V([J$1], N.prototype, "unwatchFile");
var Ve = N;
var WebOSFS = /* @__PURE__ */ function() {
  function WebOSFS2() {
    _classCallCheck(this, WebOSFS2);
    this._emitter = new vscode__namespace.EventEmitter();
    this._bufferedEvents = [];
    this.disk = new Ve();
    this.ready = this.disk.ready;
    this._onDidChangeFile = new vscode__namespace.EventEmitter();
  }
  return _createClass(WebOSFS2, [{
    key: "stat",
    value: function() {
      var _stat = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(uri) {
        var info;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1)
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.ready;
              case 2:
                _context.next = 4;
                return this.disk.stat(uri.path);
              case 4:
                info = _context.sent;
                console.log("stat: uri.path=".concat(uri.path), uri, info);
                if (!(info.type === "empty")) {
                  _context.next = 8;
                  break;
                }
                throw vscode__namespace.FileSystemError.FileNotFound();
              case 8:
                return _context.abrupt("return", {
                  type: info.isDirectory() ? vscode__namespace.FileType.Directory : vscode__namespace.FileType.File,
                  ctime: Date.now(),
                  mtime: Date.now(),
                  size: info.size
                });
              case 9:
              case "end":
                return _context.stop();
            }
        }, _callee, this);
      }));
      function stat(_x) {
        return _stat.apply(this, arguments);
      }
      return stat;
    }()
  }, {
    key: "readDirectory",
    value: function() {
      var _readDirectory = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(uri) {
        var _this = this;
        var files;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1)
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.ready;
              case 2:
                _context3.next = 4;
                return this.disk.ls(uri.path);
              case 4:
                files = _context3.sent;
                if (files) {
                  _context3.next = 7;
                  break;
                }
                return _context3.abrupt("return", []);
              case 7:
                console.log("readDirectory uri.path=".concat(uri.path), uri, files);
                return _context3.abrupt("return", Promise.all(files.map(/* @__PURE__ */ function() {
                  var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name) {
                    var stat, isDir;
                    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                      while (1)
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this.disk.stat(_.join(uri.path, name));
                          case 2:
                            stat = _context2.sent;
                            isDir = stat.isDirectory();
                            return _context2.abrupt("return", [name, isDir ? vscode__namespace.FileType.Directory : vscode__namespace.FileType.File]);
                          case 5:
                          case "end":
                            return _context2.stop();
                        }
                    }, _callee2);
                  }));
                  return function(_x3) {
                    return _ref.apply(this, arguments);
                  };
                }())));
              case 9:
              case "end":
                return _context3.stop();
            }
        }, _callee3, this);
      }));
      function readDirectory(_x2) {
        return _readDirectory.apply(this, arguments);
      }
      return readDirectory;
    }()
    // --- manage file contents
  }, {
    key: "readFile",
    value: function() {
      var _readFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(uri) {
        var data;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1)
            switch (_context4.prev = _context4.next) {
              case 0:
                console.log("read ----", uri);
                _context4.next = 3;
                return this.ready;
              case 3:
                _context4.prev = 3;
                _context4.next = 6;
                return this.disk.read(uri.path);
              case 6:
                data = _context4.sent;
                if (data) {
                  _context4.next = 9;
                  break;
                }
                return _context4.abrupt("return", new Uint8Array());
              case 9:
                console.log("watch readFile", new TextDecoder().decode(data));
                return _context4.abrupt("return", data);
              case 13:
                _context4.prev = 13;
                _context4.t0 = _context4["catch"](3);
                throw vscode__namespace.FileSystemError.FileNotFound();
              case 16:
              case "end":
                return _context4.stop();
            }
        }, _callee4, this, [[3, 13]]);
      }));
      function readFile(_x4) {
        return _readFile.apply(this, arguments);
      }
      return readFile;
    }()
  }, {
    key: "writeFile",
    value: function() {
      var _writeFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee5(uri, content, options) {
        var path2, exist;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1)
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.ready;
              case 2:
                console.log("trigger write file", uri.path);
                path2 = uri.path;
                _context5.next = 6;
                return this.disk.exist(path2);
              case 6:
                exist = _context5.sent;
                if (!(!exist && !options.create)) {
                  _context5.next = 9;
                  break;
                }
                throw vscode__namespace.FileSystemError.FileNotFound(uri);
              case 9:
                if (!(exist && options.create && !options.overwrite)) {
                  _context5.next = 11;
                  break;
                }
                throw vscode__namespace.FileSystemError.FileExists(uri);
              case 11:
                _context5.next = 13;
                return this.disk.write(path2, content);
              case 13:
                this._fireSoon({
                  type: vscode__namespace.FileChangeType.Changed,
                  uri
                });
              case 14:
              case "end":
                return _context5.stop();
            }
        }, _callee5, this);
      }));
      function writeFile(_x5, _x6, _x7) {
        return _writeFile.apply(this, arguments);
      }
      return writeFile;
    }()
    // --- manage files/folders
  }, {
    key: "rename",
    value: function() {
      var _rename = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee6(oldUri, newUri, options) {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1)
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.ready;
              case 2:
                console.log("trigger rename file");
                _context6.t0 = !options.overwrite;
                if (!_context6.t0) {
                  _context6.next = 8;
                  break;
                }
                _context6.next = 7;
                return this.disk.exist(newUri.path);
              case 7:
                _context6.t0 = _context6.sent;
              case 8:
                if (!_context6.t0) {
                  _context6.next = 10;
                  break;
                }
                throw vscode__namespace.FileSystemError.FileExists(newUri);
              case 10:
                _context6.next = 12;
                return this.disk.move(oldUri.path, newUri.path);
              case 12:
                this._fireSoon({
                  type: vscode__namespace.FileChangeType.Deleted,
                  uri: oldUri
                }, {
                  type: vscode__namespace.FileChangeType.Created,
                  uri: newUri
                });
              case 13:
              case "end":
                return _context6.stop();
            }
        }, _callee6, this);
      }));
      function rename(_x8, _x9, _x10) {
        return _rename.apply(this, arguments);
      }
      return rename;
    }()
  }, {
    key: "delete",
    value: function() {
      var _delete2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee7(uri) {
        var dirname2, uriPath;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1)
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return this.ready;
              case 2:
                console.log("trigger delete file");
                dirname2 = uri.with({
                  path: _.dirname(uri.path)
                });
                uriPath = uri.path;
                _context7.next = 7;
                return this.disk.exist(uriPath);
              case 7:
                if (_context7.sent) {
                  _context7.next = 9;
                  break;
                }
                throw vscode__namespace.FileSystemError.FileNotFound(uri);
              case 9:
                _context7.next = 11;
                return this.disk.remove(uriPath);
              case 11:
                this._fireSoon({
                  type: vscode__namespace.FileChangeType.Changed,
                  uri: dirname2
                }, {
                  uri,
                  type: vscode__namespace.FileChangeType.Deleted
                });
              case 12:
              case "end":
                return _context7.stop();
            }
        }, _callee7, this);
      }));
      function _delete(_x11) {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
  }, {
    key: "createDirectory",
    value: function() {
      var _createDirectory = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee8(uri) {
        var dirname2, uriPath;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1)
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return this.ready;
              case 2:
                dirname2 = uri.with({
                  path: _.dirname(uri.path)
                });
                uriPath = uri.path;
                _context8.next = 6;
                return this.disk.createDir(uriPath);
              case 6:
                this._fireSoon({
                  type: vscode__namespace.FileChangeType.Changed,
                  uri: dirname2
                }, {
                  type: vscode__namespace.FileChangeType.Created,
                  uri
                });
              case 7:
              case "end":
                return _context8.stop();
            }
        }, _callee8, this);
      }));
      function createDirectory(_x12) {
        return _createDirectory.apply(this, arguments);
      }
      return createDirectory;
    }()
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "copy",
    value: function() {
      var _copy = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee9(source, destination, options) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1)
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.ready;
              case 2:
                console.log("trigger copy file", source.path, destination.path);
                _context9.next = 5;
                return this.disk.copySingle(source.path, destination.path);
              case 5:
              case "end":
                return _context9.stop();
            }
        }, _callee9, this);
      }));
      function copy(_x13, _x14, _x15) {
        return _copy.apply(this, arguments);
      }
      return copy;
    }()
  }, {
    key: "onDidChangeFile",
    get: function get() {
      return this._onDidChangeFile.event;
    }
    // @ts-ignore
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  }, {
    key: "watch",
    value: function watch(uri, options) {
      var _this2 = this;
      console.log("watch listen", uri, options);
      var watcher = this.disk.watch(uri.path, {
        recursive: options.recursive
      }, /* @__PURE__ */ function() {
        var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee10(event, filename) {
          var filepath, type;
          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1)
              switch (_context10.prev = _context10.next) {
                case 0:
                  _context10.next = 2;
                  return _this2.ready;
                case 2:
                  console.log("watch", event, filename);
                  if (!filename) {
                    _context10.next = 16;
                    break;
                  }
                  filepath = _.join(uri.path, filename);
                  type = vscode__namespace.FileChangeType.Changed;
                  if (!(event !== "change")) {
                    _context10.next = 15;
                    break;
                  }
                  _context10.next = 9;
                  return _this2.disk.exist(filepath);
                case 9:
                  if (!_context10.sent) {
                    _context10.next = 13;
                    break;
                  }
                  _context10.t0 = vscode__namespace.FileChangeType.Created;
                  _context10.next = 14;
                  break;
                case 13:
                  _context10.t0 = vscode__namespace.FileChangeType.Deleted;
                case 14:
                  type = _context10.t0;
                case 15:
                  _this2._onDidChangeFile.fire([{
                    type,
                    uri: uri.with({
                      path: filepath
                    })
                  }]);
                case 16:
                case "end":
                  return _context10.stop();
              }
          }, _callee10);
        }));
        return function(_x16, _x17) {
          return _ref2.apply(this, arguments);
        };
      }());
      return {
        dispose: function dispose() {
          return watcher.close();
        }
      };
    }
  }, {
    key: "_fireSoon",
    value: function _fireSoon() {
      var _this$_bufferedEvents, _this3 = this;
      (_this$_bufferedEvents = this._bufferedEvents).push.apply(_this$_bufferedEvents, arguments);
      if (this._fireSoonHandle) {
        clearTimeout(this._fireSoonHandle);
      }
      this._fireSoonHandle = setTimeout(function() {
        _this3._emitter.fire(_this3._bufferedEvents);
        _this3._bufferedEvents.length = 0;
      }, 5);
    }
  }]);
}();
function U(n, o) {
  (o == null || o > n.length) && (o = n.length);
  for (var a = 0, u = Array(o); a < o; a++)
    u[a] = n[a];
  return u;
}
function X(n, o, a, u, f, s, h) {
  try {
    var y = n[s](h), p2 = y.value;
  } catch (d) {
    return void a(d);
  }
  y.done ? o(p2) : Promise.resolve(p2).then(u, f);
}
function Y(n) {
  return function() {
    var o = this, a = arguments;
    return new Promise(function(u, f) {
      var s = n.apply(o, a);
      function h(p2) {
        X(s, u, f, h, y, "next", p2);
      }
      function y(p2) {
        X(s, u, f, h, y, "throw", p2);
      }
      h(void 0);
    });
  };
}
function Z(n, o) {
  if (!(n instanceof o))
    throw new TypeError("Cannot call a class as a function");
}
function tt(n, o) {
  for (var a = 0; a < o.length; a++) {
    var u = o[a];
    u.enumerable = u.enumerable || false, u.configurable = true, "value" in u && (u.writable = true), Object.defineProperty(n, at(u.key), u);
  }
}
function et(n, o, a) {
  return tt(n.prototype, o), Object.defineProperty(n, "prototype", {
    writable: false
  }), n;
}
function rt(n, o) {
  var a = typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (!a) {
    if (Array.isArray(n) || (a = it(n)) || o) {
      a && (n = a);
      var u = 0, f = function() {
      };
      return {
        s: f,
        n: function() {
          return u >= n.length ? {
            done: true
          } : {
            done: false,
            value: n[u++]
          };
        },
        e: function(p2) {
          throw p2;
        },
        f
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s, h = true, y = false;
  return {
    s: function() {
      a = a.call(n);
    },
    n: function() {
      var p2 = a.next();
      return h = p2.done, p2;
    },
    e: function(p2) {
      y = true, s = p2;
    },
    f: function() {
      try {
        h || a.return == null || a.return();
      } finally {
        if (y)
          throw s;
      }
    }
  };
}
function M() {
  M = function() {
    return o;
  };
  var n, o = {}, a = Object.prototype, u = a.hasOwnProperty, f = Object.defineProperty || function(e, t, r) {
    e[t] = r.value;
  }, s = typeof Symbol == "function" ? Symbol : {}, h = s.iterator || "@@iterator", y = s.asyncIterator || "@@asyncIterator", p2 = s.toStringTag || "@@toStringTag";
  function d(e, t, r) {
    return Object.defineProperty(e, t, {
      value: r,
      enumerable: true,
      configurable: true,
      writable: true
    }), e[t];
  }
  try {
    d({}, "");
  } catch {
    d = function(t, r, c) {
      return t[r] = c;
    };
  }
  function m2(e, t, r, c) {
    var i = t && t.prototype instanceof x2 ? t : x2, l2 = Object.create(i.prototype), g = new W(c || []);
    return f(l2, "_invoke", {
      value: Q2(e, r, g)
    }), l2;
  }
  function E2(e, t, r) {
    try {
      return {
        type: "normal",
        arg: e.call(t, r)
      };
    } catch (c) {
      return {
        type: "throw",
        arg: c
      };
    }
  }
  o.wrap = m2;
  var O2 = "suspendedStart", G2 = "suspendedYield", j2 = "executing", S2 = "completed", w2 = {};
  function x2() {
  }
  function L2() {
  }
  function _2() {
  }
  var T = {};
  d(T, h, function() {
    return this;
  });
  var N2 = Object.getPrototypeOf, v2 = N2 && N2(N2(K2([])));
  v2 && v2 !== a && u.call(v2, h) && (T = v2);
  var I2 = _2.prototype = x2.prototype = Object.create(T);
  function C(e) {
    ["next", "throw", "return"].forEach(function(t) {
      d(e, t, function(r) {
        return this._invoke(t, r);
      });
    });
  }
  function F(e, t) {
    function r(i, l2, g, b) {
      var k2 = E2(e[i], e, l2);
      if (k2.type !== "throw") {
        var A2 = k2.arg, D2 = A2.value;
        return D2 && typeof D2 == "object" && u.call(D2, "__await") ? t.resolve(D2.__await).then(function(P2) {
          r("next", P2, g, b);
        }, function(P2) {
          r("throw", P2, g, b);
        }) : t.resolve(D2).then(function(P2) {
          A2.value = P2, g(A2);
        }, function(P2) {
          return r("throw", P2, g, b);
        });
      }
      b(k2.arg);
    }
    var c;
    f(this, "_invoke", {
      value: function(i, l2) {
        function g() {
          return new t(function(b, k2) {
            r(i, l2, b, k2);
          });
        }
        return c = c ? c.then(g, g) : g();
      }
    });
  }
  function Q2(e, t, r) {
    var c = O2;
    return function(i, l2) {
      if (c === j2)
        throw Error("Generator is already running");
      if (c === S2) {
        if (i === "throw")
          throw l2;
        return {
          value: n,
          done: true
        };
      }
      for (r.method = i, r.arg = l2; ; ) {
        var g = r.delegate;
        if (g) {
          var b = H2(g, r);
          if (b) {
            if (b === w2)
              continue;
            return b;
          }
        }
        if (r.method === "next")
          r.sent = r._sent = r.arg;
        else if (r.method === "throw") {
          if (c === O2)
            throw c = S2, r.arg;
          r.dispatchException(r.arg);
        } else
          r.method === "return" && r.abrupt("return", r.arg);
        c = j2;
        var k2 = E2(e, t, r);
        if (k2.type === "normal") {
          if (c = r.done ? S2 : G2, k2.arg === w2)
            continue;
          return {
            value: k2.arg,
            done: r.done
          };
        }
        k2.type === "throw" && (c = S2, r.method = "throw", r.arg = k2.arg);
      }
    };
  }
  function H2(e, t) {
    var r = t.method, c = e.iterator[r];
    if (c === n)
      return t.delegate = null, r === "throw" && e.iterator.return && (t.method = "return", t.arg = n, H2(e, t), t.method === "throw") || r !== "return" && (t.method = "throw", t.arg = new TypeError("The iterator does not provide a '" + r + "' method")), w2;
    var i = E2(c, e.iterator, t.arg);
    if (i.type === "throw")
      return t.method = "throw", t.arg = i.arg, t.delegate = null, w2;
    var l2 = i.arg;
    return l2 ? l2.done ? (t[e.resultName] = l2.value, t.next = e.nextLoc, t.method !== "return" && (t.method = "next", t.arg = n), t.delegate = null, w2) : l2 : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, w2);
  }
  function V2(e) {
    var t = {
      tryLoc: e[0]
    };
    1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);
  }
  function $2(e) {
    var t = e.completion || {};
    t.type = "normal", delete t.arg, e.completion = t;
  }
  function W(e) {
    this.tryEntries = [{
      tryLoc: "root"
    }], e.forEach(V2, this), this.reset(true);
  }
  function K2(e) {
    if (e || e === "") {
      var t = e[h];
      if (t)
        return t.call(e);
      if (typeof e.next == "function")
        return e;
      if (!isNaN(e.length)) {
        var r = -1, c = function i() {
          for (; ++r < e.length; )
            if (u.call(e, r))
              return i.value = e[r], i.done = false, i;
          return i.value = n, i.done = true, i;
        };
        return c.next = c;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return L2.prototype = _2, f(I2, "constructor", {
    value: _2,
    configurable: true
  }), f(_2, "constructor", {
    value: L2,
    configurable: true
  }), L2.displayName = d(_2, p2, "GeneratorFunction"), o.isGeneratorFunction = function(e) {
    var t = typeof e == "function" && e.constructor;
    return !!t && (t === L2 || (t.displayName || t.name) === "GeneratorFunction");
  }, o.mark = function(e) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e, _2) : (e.__proto__ = _2, d(e, p2, "GeneratorFunction")), e.prototype = Object.create(I2), e;
  }, o.awrap = function(e) {
    return {
      __await: e
    };
  }, C(F.prototype), d(F.prototype, y, function() {
    return this;
  }), o.AsyncIterator = F, o.async = function(e, t, r, c, i) {
    i === void 0 && (i = Promise);
    var l2 = new F(m2(e, t, r, c), i);
    return o.isGeneratorFunction(t) ? l2 : l2.next().then(function(g) {
      return g.done ? g.value : l2.next();
    });
  }, C(I2), d(I2, p2, "Generator"), d(I2, h, function() {
    return this;
  }), d(I2, "toString", function() {
    return "[object Generator]";
  }), o.keys = function(e) {
    var t = Object(e), r = [];
    for (var c in t)
      r.push(c);
    return r.reverse(), function i() {
      for (; r.length; ) {
        var l2 = r.pop();
        if (l2 in t)
          return i.value = l2, i.done = false, i;
      }
      return i.done = true, i;
    };
  }, o.values = K2, W.prototype = {
    constructor: W,
    reset: function(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = n, this.done = false, this.delegate = null, this.method = "next", this.arg = n, this.tryEntries.forEach($2), !e)
        for (var t in this)
          t.charAt(0) === "t" && u.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = n);
    },
    stop: function() {
      this.done = true;
      var e = this.tryEntries[0].completion;
      if (e.type === "throw")
        throw e.arg;
      return this.rval;
    },
    dispatchException: function(e) {
      if (this.done)
        throw e;
      var t = this;
      function r(k2, A2) {
        return l2.type = "throw", l2.arg = e, t.next = k2, A2 && (t.method = "next", t.arg = n), !!A2;
      }
      for (var c = this.tryEntries.length - 1; c >= 0; --c) {
        var i = this.tryEntries[c], l2 = i.completion;
        if (i.tryLoc === "root")
          return r("end");
        if (i.tryLoc <= this.prev) {
          var g = u.call(i, "catchLoc"), b = u.call(i, "finallyLoc");
          if (g && b) {
            if (this.prev < i.catchLoc)
              return r(i.catchLoc, true);
            if (this.prev < i.finallyLoc)
              return r(i.finallyLoc);
          } else if (g) {
            if (this.prev < i.catchLoc)
              return r(i.catchLoc, true);
          } else {
            if (!b)
              throw Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc)
              return r(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function(e, t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var c = this.tryEntries[r];
        if (c.tryLoc <= this.prev && u.call(c, "finallyLoc") && this.prev < c.finallyLoc) {
          var i = c;
          break;
        }
      }
      i && (e === "break" || e === "continue") && i.tryLoc <= t && t <= i.finallyLoc && (i = null);
      var l2 = i ? i.completion : {};
      return l2.type = e, l2.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, w2) : this.complete(l2);
    },
    complete: function(e, t) {
      if (e.type === "throw")
        throw e.arg;
      return e.type === "break" || e.type === "continue" ? this.next = e.arg : e.type === "return" ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : e.type === "normal" && t && (this.next = t), w2;
    },
    finish: function(e) {
      for (var t = this.tryEntries.length - 1; t >= 0; --t) {
        var r = this.tryEntries[t];
        if (r.finallyLoc === e)
          return this.complete(r.completion, r.afterLoc), $2(r), w2;
      }
    },
    catch: function(e) {
      for (var t = this.tryEntries.length - 1; t >= 0; --t) {
        var r = this.tryEntries[t];
        if (r.tryLoc === e) {
          var c = r.completion;
          if (c.type === "throw") {
            var i = c.arg;
            $2(r);
          }
          return i;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(e, t, r) {
      return this.delegate = {
        iterator: K2(e),
        resultName: t,
        nextLoc: r
      }, this.method === "next" && (this.arg = n), w2;
    }
  }, o;
}
function nt(n, o) {
  if (typeof n != "object" || !n)
    return n;
  var a = n[Symbol.toPrimitive];
  if (a !== void 0) {
    var u = a.call(n, o);
    if (typeof u != "object")
      return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(n);
}
function at(n) {
  var o = nt(n, "string");
  return typeof o == "symbol" ? o : o + "";
}
function it(n, o) {
  if (n) {
    if (typeof n == "string")
      return U(n, o);
    var a = {}.toString.call(n).slice(8, -1);
    return a === "Object" && n.constructor && (a = n.constructor.name), a === "Map" || a === "Set" ? Array.from(n) : a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a) ? U(n, o) : void 0;
  }
}
function q() {
  var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return "".concat(n).concat(Date.now().toString().substring(5), "-").concat(Math.random().toString(16).substring(2));
}
var B = R$2.createInstance({
  name: "weoos-messenger",
  driver: R$2.INDEXEDDB
}), z = "weoos-messenger", J = 500, st = /* @__PURE__ */ function() {
  function n() {
    var o = this, a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = a.id, f = a.interval, s = f === void 0 ? J : f;
    Z(this, n), this.lns = {}, this.timer = null, this.triggerMsg = /* @__PURE__ */ new Set(), this.id = u || q("ms"), this.timer = setInterval(function() {
      o.checkMessage();
    }, s);
  }
  return et(n, [{
    key: "on",
    value: function(a, u) {
      var f = this, s = this.lns[a];
      return s || (s = this.lns[a] = []), s.push(u), function() {
        f.off(a, u);
      };
    }
  }, {
    key: "once",
    value: function(a, u) {
      var f = this.on(a, function(s, h) {
        u(s, h), f();
      });
      return f;
    }
  }, {
    key: "off",
    value: function(a, u) {
      var f = this.lns[a];
      if (f) {
        var s = f.indexOf(u);
        s !== -1 && f.splice(s, 1);
      }
    }
  }, {
    key: "emit",
    value: function() {
      var o = Y(/* @__PURE__ */ M().mark(function u(f, s) {
        var h, y, p2;
        return M().wrap(function(m2) {
          for (; ; )
            switch (m2.prev = m2.next) {
              case 0:
                return m2.next = 2, this._read();
              case 2:
                return h = m2.sent, y = {
                  ts: Date.now(),
                  id: q(),
                  from: this.id,
                  type: f,
                  data: s
                }, h.length === 0 ? h.push(y) : (p2 = h.findIndex(function(E2) {
                  return E2.ts > y.ts;
                }), p2 === -1 ? h.push(y) : h.splice(p2, 0, y)), m2.next = 7, this._write(h);
              case 7:
              case "end":
                return m2.stop();
            }
        }, u, this);
      }));
      function a(u, f) {
        return o.apply(this, arguments);
      }
      return a;
    }()
  }, {
    key: "_read",
    value: function() {
      var o = Y(/* @__PURE__ */ M().mark(function u() {
        return M().wrap(function(s) {
          for (; ; )
            switch (s.prev = s.next) {
              case 0:
                return s.next = 2, B.getItem(z);
              case 2:
                if (s.t0 = s.sent, s.t0) {
                  s.next = 5;
                  break;
                }
                s.t0 = [];
              case 5:
                return s.abrupt("return", s.t0);
              case 6:
              case "end":
                return s.stop();
            }
        }, u);
      }));
      function a() {
        return o.apply(this, arguments);
      }
      return a;
    }()
  }, {
    key: "_write",
    value: function(a) {
      return B.setItem(z, a);
    }
  }, {
    key: "checkMessage",
    value: function() {
      var o = Y(/* @__PURE__ */ M().mark(function u() {
        var f, s, h, y, p2, d, m2, E2, O2, G2, j2, S2, w2, x2, L2, _2, T;
        return M().wrap(function(v2) {
          for (; ; )
            switch (v2.prev = v2.next) {
              case 0:
                return v2.next = 2, this._read();
              case 2:
                if (f = v2.sent, f.length !== 0) {
                  v2.next = 5;
                  break;
                }
                return v2.abrupt("return");
              case 5:
                s = [], h = Date.now(), y = function(C) {
                  return h - C > J * 2;
                }, p2 = [], d = 0;
              case 10:
                if (!(d < f.length)) {
                  v2.next = 25;
                  break;
                }
                if (m2 = f[d], !y(m2.ts)) {
                  v2.next = 16;
                  break;
                }
                return s.push(d), this.triggerMsg.delete(m2.id), v2.abrupt("continue", 22);
              case 16:
                if (m2.from !== this.id) {
                  v2.next = 18;
                  break;
                }
                return v2.abrupt("continue", 22);
              case 18:
                if (!this.triggerMsg.has(m2.id)) {
                  v2.next = 20;
                  break;
                }
                return v2.abrupt("continue", 22);
              case 20:
                p2.push(m2), this.triggerMsg.add(m2.id);
              case 22:
                d++, v2.next = 10;
                break;
              case 25:
                if (!s.length) {
                  v2.next = 29;
                  break;
                }
                for (E2 = s.length - 1; E2 >= 0; E2--)
                  f.splice(s[E2], 1);
                return v2.next = 29, this._write(f);
              case 29:
                for (O2 = 0, G2 = p2; O2 < G2.length; O2++)
                  if (j2 = G2[O2], S2 = j2.type, w2 = j2.data, x2 = this.lns[S2], x2 != null && x2.length) {
                    L2 = rt(x2);
                    try {
                      for (L2.s(); !(_2 = L2.n()).done; )
                        T = _2.value, T(w2, j2);
                    } catch (I2) {
                      L2.e(I2);
                    } finally {
                      L2.f();
                    }
                  }
              case 30:
              case "end":
                return v2.stop();
            }
        }, u, this);
      }));
      function a() {
        return o.apply(this, arguments);
      }
      return a;
    }()
  }, {
    key: "destroy",
    value: function() {
      clearInterval(this.timer), this.lns = {};
    }
  }]);
}();
var Messenger = /* @__PURE__ */ function(_WeoOSEvent) {
  function Messenger2() {
    _classCallCheck(this, Messenger2);
    return _callSuper(this, Messenger2, arguments);
  }
  _inherits(Messenger2, _WeoOSEvent);
  return _createClass(Messenger2);
}(st);
function genePath(path) {
  if (path[0] !== "/")
    path = "/".concat(path);
  var uri = vscode__namespace.Uri.parse("wosfs:".concat(path));
  console.log("genePath", uri.toString());
  return uri;
}
function openFolder(dirPath) {
  var replace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  vscode__namespace.workspace.updateWorkspaceFolders(0, replace ? 1 : 0, {
    uri: genePath(dirPath)
  });
}
function openFile(_x) {
  return _openFile.apply(this, arguments);
}
function _openFile() {
  _openFile = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(filePath) {
    var document2;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return vscode__namespace.workspace.openTextDocument(genePath(filePath));
          case 2:
            document2 = _context.sent;
            _context.next = 5;
            return vscode__namespace.window.showTextDocument(document2);
          case 5:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return _openFile.apply(this, arguments);
}
function activate(_x2) {
  return _activate.apply(this, arguments);
}
function _activate() {
  _activate = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(context) {
    var wosfs, msg;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1)
        switch (_context4.prev = _context4.next) {
          case 0:
            wosfs = new WebOSFS();
            msg = new Messenger({
              id: "fs-ext"
            });
            msg.on("open-folder", function(_ref) {
              var path = _ref.path, replace = _ref.replace;
              console.log("open-folder", path, replace);
              openFolder(path, replace);
            });
            msg.on("open-file", /* @__PURE__ */ function() {
              var _ref2 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(path) {
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1)
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        openFile(path);
                      case 1:
                      case "end":
                        return _context2.stop();
                    }
                }, _callee2);
              }));
              return function(_x3) {
                return _ref2.apply(this, arguments);
              };
            }());
            console.log('WebOSFS says "Hello"');
            context.subscriptions.push(vscode__namespace.workspace.registerFileSystemProvider("wosfs", wosfs, {
              isCaseSensitive: true
            }));
            context.subscriptions.push(vscode__namespace.commands.registerCommand("wosfs.workspaceInit", /* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3() {
              var dirPath;
              return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                while (1)
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return vscode__namespace.window.showInputBox({
                        prompt: "Please input directory path.",
                        placeHolder: "Such as: /path/to/your/directory"
                      });
                    case 2:
                      dirPath = _context3.sent;
                      if (dirPath) {
                        try {
                          openFolder(dirPath, true);
                        } catch (error) {
                        }
                      }
                    case 4:
                    case "end":
                      return _context3.stop();
                  }
              }, _callee3);
            }))));
            _context4.next = 9;
            return wosfs.ready;
          case 9:
            _context4.next = 11;
            return wosfs.disk.exist("/hello/hello.js");
          case 11:
            if (_context4.sent) {
              _context4.next = 14;
              break;
            }
            _context4.next = 14;
            return wosfs.disk.createFile("/hello/hello.js", ge$1('console.log("Hello world!");'), {
              ensure: true
            });
          case 14:
          case "end":
            return _context4.stop();
        }
    }, _callee4);
  }));
  return _activate.apply(this, arguments);
}
function deactivate() {
}
exports.activate = activate;
exports.deactivate = deactivate;
